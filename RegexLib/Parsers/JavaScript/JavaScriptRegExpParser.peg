@namespace RegexLib.Parsers.JavaScript
@classname JavaScriptRegExpParser
@accessibility internal
@using System.Globalization
@using System.Linq
@members
{
    private static HashSet<UnicodeCategory> unicodeLetterCategories = new HashSet<UnicodeCategory>
    {
        UnicodeCategory.UppercaseLetter,
        UnicodeCategory.LowercaseLetter,
        UnicodeCategory.TitlecaseLetter,
        UnicodeCategory.ModifierLetter,
        UnicodeCategory.OtherLetter,
        UnicodeCategory.LetterNumber,
    };

    private static HashSet<UnicodeCategory> unicodeCombiningMarkCategories = new HashSet<UnicodeCategory>
    {
        UnicodeCategory.NonSpacingMark,
        UnicodeCategory.SpacingCombiningMark,
    };

    private static HashSet<UnicodeCategory> unicodeDigitCategories = new HashSet<UnicodeCategory>
    {
        UnicodeCategory.DecimalDigitNumber,
    };

    private static HashSet<UnicodeCategory> unicodeConnectorPunctuationCategories = new HashSet<UnicodeCategory>
    {
        UnicodeCategory.ConnectorPunctuation,
    };
}

Pattern <RegexNode>
  = p:Disjunction EOF { p }

Disjunction <RegexNode>
  = first:Alternative "|" rest:Disjunction { new AlternationNode(first, rest) }
  / Alternative

Alternative <RegexNode> -memoize
  = Concatenation
  / { new EmptyNode() }

Concatenation <RegexNode>
  = first:Term rest:Concatenation { new ConcatenationNode(first, rest) }
  / Term

Term <RegexNode> -memoize
  = Assertion
  / a:Atom q:Quantifier { new RepetitionNode(a, q.Min, q.Max, q.Eager) }
  / Atom

Assertion <RegexNode>
  = "^"                   { new StringStartAnchorNode() }
  / "$"                   { new StringEndAnchorNode() }
  // "\b"                  { throw new NotImplementedException() }
  // "\B"                  { throw new NotImplementedException() }
  // "(?=" Disjunction ")" { throw new NotImplementedException() }
  // "(?!" Disjunction ")" { throw new NotImplementedException() }

Quantifier <Quantifier>
  = q:QuantifierPrefix "?" { new Quantifier(q.Min, q.Max, eager: false) }
  / QuantifierPrefix

QuantifierPrefix <Quantifier> -memoize
  = "*"                                             { new Quantifier(min: 0) }
  / "+"                                             { new Quantifier(min: 1) }
  / "?"                                             { new Quantifier(min: 0, max: 1) }
  / "{" num:DecimalDigits                       "}" {{ var numValue = int.Parse(num); return new Quantifier(min: numValue, max: numValue); }}
  / "{" min:DecimalDigits ","                   "}" {{ var minValue = int.Parse(min); return new Quantifier(minValue); }}
  / "{" min:DecimalDigits "," max:DecimalDigits "}" {{ var minValue = int.Parse(min); var maxValue = int.Parse(max); return new Quantifier(minValue, maxValue); }}

Atom <RegexNode> -memoize
  = c:PatternCharacter      { new CharacterClassNode(c, c) }
  / "."                     { new CharacterClassNode() } // TODO: Newline?
  / "\\" c:AtomEscape       { c }
  / CharacterClass
  / "(" d:Disjunction ")"   { d }
  / "(?:" d:Disjunction ")" { d }

PatternCharacter <char>
  = ![\^$\\.*+?()[\]{}|] c:SourceCharacter { c }

AtomEscape <RegexNode>
  = e:DecimalEscape {{ if (e is char) return new CharacterClassNode((char)e); else throw new NotImplementedException(); }}
  / c:CharacterEscape { new CharacterClassNode(c) }
  / e:CharacterClassEscape { new CharacterClassNode(e) }

CharacterEscape
  = ControlEscape
  / "c" c:ControlLetter { c }
  / HexEscapeSequence
  / UnicodeEscapeSequence
  / IdentityEscape

ControlEscape <char>
  = "t" { '\u0009' } // <HT>
  / "n" { '\u000A' } // <LF>
  / "v" { '\u000B' } // <VT>
  / "f" { '\u000C' } // <FF>
  / "r" { '\u000D' } // <CR>

ControlLetter <char>
  = c:[a-zA-Z] { (char)((int)c[0] % 32) }

IdentityEscape <char>
  = !IdentifierPart c:SourceCharacter { c }
  / "\u200D"                          { '\u200D' } // <ZWJ>
  / "\u200C"                          { '\u200C' } // <ZWNJ>

DecimalEscape <object>
  = i:DecimalIntegerLiteral !DecimalDigit { i == 0 ? (object)'\0' : (object)i }

CharacterClassEscape <CharacterRange[]>
  = "d" { new[] { new CharacterRange('0', '9') } }
  / "D" { new[] { new CharacterRange(char.MinValue, (char)('0' - 1)), new CharacterRange((char)('9' + 1), char.MaxValue) } }
  / "w" { new[] { new CharacterRange('0', '9'), new CharacterRange('A', 'Z'), new CharacterRange('_'), new CharacterRange('a', 'z') } }
  / "W" { new[] { new CharacterRange(char.MinValue, (char)('0' - 1)), new CharacterRange((char)('9' + 1), (char)('A' - 1)), new CharacterRange((char)('Z' + 1), (char)('_' - 1)), new CharacterRange((char)('_' + 1), (char)('a' - 1)), new CharacterRange((char)('z' + 1), char.MaxValue) } }
  / "s" { new[] { new CharacterRange('\u0009'), new CharacterRange('\u000B'), new CharacterRange('\u000C'), new CharacterRange('\u0020'), new CharacterRange('\u00A0'), new CharacterRange('\uFEFF') } } // TODO: Unicode Zs (space separator) category.
  / "S" { new[] { new CharacterRange() } } // TODO: Negate above range.

CharacterClass <CharacterClassNode>
  = "[" neg:"^"? ranges:ClassRanges "]" { new CharacterClassNode(ranges /*, negated: neg.Any()*/) }

ClassRanges <IEnumerable<CharacterRange>>
  = NonemptyClassRanges
  / { new CharacterRange[0] }

NonemptyClassRanges <IEnumerable<CharacterRange>>
  = a:ClassAtom "-" b:ClassAtom rest:ClassRanges {{
        if (a.Length > 1 || a[0].MinChar != a[0].MaxChar ||
            b.Length > 1 || b[0].MinChar != b[0].MaxChar)
        {
            throw ExceptionHelper(aStart, _ => "SyntaxError");
        }

        return new[] { new CharacterRange(a[0].MinChar, b[0].MinChar) }.Concat(rest);
    }}
  / a:ClassAtom rest:NonemptyClassRangesNoDash   { a.Concat(rest) }
  / a:ClassAtom

NonemptyClassRangesNoDash <IEnumerable<CharacterRange>>
  = a:ClassAtomNoDash "-" b:ClassAtom rest:ClassRanges {{
        if (a.Length > 1 || a[0].MinChar != a[0].MaxChar ||
            b.Length > 1 || b[0].MinChar != b[0].MaxChar)
        {
            throw ExceptionHelper(aStart, _ => "SyntaxError");
        }

        return new[] { new CharacterRange(a[0].MinChar, b[0].MinChar) }.Concat(rest);
    }}
  / a:ClassAtomNoDash rest:NonemptyClassRangesNoDash   { a.Concat(rest) }
  / a:ClassAtom

ClassAtom <CharacterRange[]>
  = "-" { new[] { new CharacterRange('-', '-') } }
  / ClassAtomNoDash

ClassAtomNoDash <CharacterRange[]>
  = ![\\\]\-] c:SourceCharacter { new[] { new CharacterRange(c, c) } }
  / "\\" c:ClassEscape          { c }

ClassEscape <CharacterRange[]>
  = e:DecimalEscape (&{e is char} / #ERROR{ "A backreference is invalid in a character class." }) { new[] { new CharacterRange((char)e, (char)e) } }
  / "b"                                                                                           { new[] { new CharacterRange('\u0008', '\u0008') } }
  / c:CharacterEscape                                                                             { new[] { new CharacterRange(c, c) } }
  / e:CharacterClassEscape                                                                        { e }

DecimalDigit
  = [0-9]

DecimalDigits -memoize
  = digits:DecimalDigit+ { string.Concat(digits.ToArray()) }

SourceCharacter <char>
  = c:. { c[0] }

DecimalIntegerLiteral <int>
  = "0"                                  { 0 }
  / digits:(NonZeroDigit DecimalDigits?) { int.Parse(digits) }

HexEscapeSequence <char>
  = "x" digits:(HexDigit HexDigit) { (char)Convert.ToInt32(digits, 16) }

UnicodeEscapeSequence <char>
  = "u" digits:(HexDigit HexDigit HexDigit HexDigit) { (char)Convert.ToInt32(digits, 16) }

NonZeroDigit
  = [1-9]

HexDigit
  = [0-9a-fA-F]

IdentifierPart
  = IdentifierStart
  / UnicodeCombiningMark
  / UnicodeDigit
  / UnicodeConnectorPunctuation
  / "\u200D" // <ZWJ>
  / "\u200C" // <ZWNJ>

IdentifierStart
  = UnicodeLetter
  / "$"
  / "_"
  / "\\" UnicodeEscapeSequence

UnicodeLetter
  = char:. &{ unicodeLetterCategories.Contains(char.GetUnicodeCategory(@char[0])) }

UnicodeCombiningMark
  = char:. &{ unicodeCombiningMarkCategories.Contains(char.GetUnicodeCategory(@char[0])) }

UnicodeDigit
  = char:. &{ unicodeDigitCategories.Contains(char.GetUnicodeCategory(@char[0])) }

UnicodeConnectorPunctuation
  = char:. &{ unicodeConnectorPunctuationCategories.Contains(char.GetUnicodeCategory(@char[0])) }

EOF = !.
