//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g 2012-07-12 19:18:16

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  RegexLib.Parsers.JavaScript 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
 internal  partial class JavaScriptRegExpParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "CHAR", "PIPE"
	};
	public const int EOF=-1;
	public const int CHAR=4;
	public const int PIPE=5;

	public JavaScriptRegExpParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public JavaScriptRegExpParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return JavaScriptRegExpParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_pattern();
	partial void LeaveRule_pattern();

	// $ANTLR start "pattern"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:10:8: public pattern returns [RegexNode value] : disjunction EOF ;
	[GrammarRule("pattern")]
	public RegexNode pattern()
	{
		EnterRule_pattern();
		EnterRule("pattern", 1);
		TraceIn("pattern", 1);
		RegexNode value = default(RegexNode);


		RegexNode disjunction1 = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "pattern");
		DebugLocation(10, 1);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:11:2: ( disjunction EOF )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:11:4: disjunction EOF
			{
			DebugLocation(11, 4);
			PushFollow(Follow._disjunction_in_pattern51);
			disjunction1=disjunction();
			PopFollow();

			DebugLocation(11, 16);
			Match(input,EOF,Follow._EOF_in_pattern53); 
			DebugLocation(11, 20);
			 return disjunction1; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("pattern", 1);
			LeaveRule("pattern", 1);
			LeaveRule_pattern();
		}
		DebugLocation(12, 1);
		} finally { DebugExitRule(GrammarFileName, "pattern"); }
		return value;

	}
	// $ANTLR end "pattern"

	partial void EnterRule_disjunction();
	partial void LeaveRule_disjunction();

	// $ANTLR start "disjunction"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:14:1: disjunction returns [RegexNode value] : term= atom ( PIPE rest= disjunction )? ;
	[GrammarRule("disjunction")]
	private RegexNode disjunction()
	{
		EnterRule_disjunction();
		EnterRule("disjunction", 2);
		TraceIn("disjunction", 2);
		RegexNode value = default(RegexNode);


		RegexNode term = default(RegexNode);
		RegexNode rest = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "disjunction");
		DebugLocation(14, 1);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:15:2: (term= atom ( PIPE rest= disjunction )? )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:15:4: term= atom ( PIPE rest= disjunction )?
			{
			DebugLocation(15, 8);
			PushFollow(Follow._atom_in_disjunction72);
			term=atom();
			PopFollow();

			DebugLocation(15, 14);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:15:14: ( PIPE rest= disjunction )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==PIPE))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:15:15: PIPE rest= disjunction
				{
				DebugLocation(15, 15);
				Match(input,PIPE,Follow._PIPE_in_disjunction75); 
				DebugLocation(15, 24);
				PushFollow(Follow._disjunction_in_disjunction79);
				rest=disjunction();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(15, 39);
			 return rest != null ? new AlternationNode(term, rest) : term; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("disjunction", 2);
			LeaveRule("disjunction", 2);
			LeaveRule_disjunction();
		}
		DebugLocation(16, 1);
		} finally { DebugExitRule(GrammarFileName, "disjunction"); }
		return value;

	}
	// $ANTLR end "disjunction"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:1: atom returns [RegexNode value] : CHAR ;
	[GrammarRule("atom")]
	private RegexNode atom()
	{
		EnterRule_atom();
		EnterRule("atom", 3);
		TraceIn("atom", 3);
		RegexNode value = default(RegexNode);


		IToken CHAR2 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(22, 1);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:23:2: ( CHAR )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:23:4: CHAR
			{
			DebugLocation(23, 4);
			CHAR2=(IToken)Match(input,CHAR,Follow._CHAR_in_atom109); 
			DebugLocation(23, 9);
			 return new CharacterClassNode(CHAR2.Text[0]); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 3);
			LeaveRule("atom", 3);
			LeaveRule_atom();
		}
		DebugLocation(24, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return value;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _disjunction_in_pattern51 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_pattern53 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_disjunction72 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _PIPE_in_disjunction75 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _disjunction_in_disjunction79 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_in_atom109 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  RegexLib.Parsers.JavaScript 
