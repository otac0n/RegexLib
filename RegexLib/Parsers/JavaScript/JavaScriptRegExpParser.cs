//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g 2012-06-25 09:47:22

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class JavaScriptRegExpParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ControlEscape", "ControlLetter", "DecimalDigit", "DecimalDigits", "DecimalIntegerLiteral", "HexDigit", "HexEscapeSequence", "IdentityEscape", "NonZeroDigit", "UnicodeEscapeSequence", "'$'", "'('", "'(:?'", "'(?!'", "'(?='", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'?'", "'D'", "'S'", "'W'", "'['", "'[^'", "'\\\\'", "'\\\\B'", "'\\\\b'", "']'", "'^'", "'b'", "'c'", "'d'", "'s'", "'w'", "'{'", "'|'", "'}'"
	};
	public const int EOF=-1;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int T__18=18;
	public const int T__19=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int T__29=29;
	public const int T__30=30;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int ControlEscape=4;
	public const int ControlLetter=5;
	public const int DecimalDigit=6;
	public const int DecimalDigits=7;
	public const int DecimalIntegerLiteral=8;
	public const int HexDigit=9;
	public const int HexEscapeSequence=10;
	public const int IdentityEscape=11;
	public const int NonZeroDigit=12;
	public const int UnicodeEscapeSequence=13;

	public JavaScriptRegExpParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public JavaScriptRegExpParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[80+1];


		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return JavaScriptRegExpParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_pattern();
	partial void LeaveRule_pattern();

	// $ANTLR start "pattern"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:9:1: pattern : disjunction EOF ;
	[GrammarRule("pattern")]
	private AstParserRuleReturnScope<object, IToken> pattern()
	{
		EnterRule_pattern();
		EnterRule("pattern", 1);
		TraceIn("pattern", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int pattern_StartIndex = input.Index;

		object root_0 = default(object);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> disjunction1 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF2_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "pattern");
		DebugLocation(9, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 1)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:10:2: ( disjunction EOF )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:10:4: disjunction EOF
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(10, 4);
			PushFollow(Follow._disjunction_in_pattern47);
			disjunction1=disjunction();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction1.Tree);
			DebugLocation(10, 16);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_pattern49); if (state.failed) return retval;
			if (state.backtracking == 0) {
			EOF2_tree = (object)adaptor.Create(EOF2);
			adaptor.AddChild(root_0, EOF2_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("pattern", 1);
			LeaveRule("pattern", 1);
			LeaveRule_pattern();
			if (state.backtracking > 0) { Memoize(input, 1, pattern_StartIndex); }

		}
		DebugLocation(11, 1);
		} finally { DebugExitRule(GrammarFileName, "pattern"); }
		return retval;

	}
	// $ANTLR end "pattern"

	partial void EnterRule_disjunction();
	partial void LeaveRule_disjunction();

	// $ANTLR start "disjunction"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:13:1: disjunction : alternative ( '|' disjunction )? ;
	[GrammarRule("disjunction")]
	private AstParserRuleReturnScope<object, IToken> disjunction()
	{
		EnterRule_disjunction();
		EnterRule("disjunction", 2);
		TraceIn("disjunction", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int disjunction_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal4 = default(IToken);
		AstParserRuleReturnScope<object, IToken> alternative3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction5 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal4_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "disjunction");
		DebugLocation(13, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 2)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:14:2: ( alternative ( '|' disjunction )? )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:14:4: alternative ( '|' disjunction )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(14, 4);
			PushFollow(Follow._alternative_in_disjunction60);
			alternative3=alternative();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, alternative3.Tree);
			DebugLocation(14, 16);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:14:16: ( '|' disjunction )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==42))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:14:17: '|' disjunction
				{
				DebugLocation(14, 17);
				char_literal4=(IToken)Match(input,42,Follow._42_in_disjunction63); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal4_tree = (object)adaptor.Create(char_literal4);
				adaptor.AddChild(root_0, char_literal4_tree);
				}
				DebugLocation(14, 21);
				PushFollow(Follow._disjunction_in_disjunction65);
				disjunction5=disjunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction5.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("disjunction", 2);
			LeaveRule("disjunction", 2);
			LeaveRule_disjunction();
			if (state.backtracking > 0) { Memoize(input, 2, disjunction_StartIndex); }

		}
		DebugLocation(15, 1);
		} finally { DebugExitRule(GrammarFileName, "disjunction"); }
		return retval;

	}
	// $ANTLR end "disjunction"

	partial void EnterRule_alternative();
	partial void LeaveRule_alternative();

	// $ANTLR start "alternative"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:17:1: alternative : ( term )* ;
	[GrammarRule("alternative")]
	private AstParserRuleReturnScope<object, IToken> alternative()
	{
		EnterRule_alternative();
		EnterRule("alternative", 3);
		TraceIn("alternative", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int alternative_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> term6 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "alternative");
		DebugLocation(17, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 3)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:18:2: ( ( term )* )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:18:4: ( term )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(18, 4);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:18:4: ( term )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if (((LA2_0>=ControlEscape && LA2_0<=18)||(LA2_0>=22 && LA2_0<=24)||(LA2_0>=26 && LA2_0<=33)||(LA2_0>=35 && LA2_0<=40)))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:18:4: term
					{
					DebugLocation(18, 4);
					PushFollow(Follow._term_in_alternative78);
					term6=term();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, term6.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("alternative", 3);
			LeaveRule("alternative", 3);
			LeaveRule_alternative();
			if (state.backtracking > 0) { Memoize(input, 3, alternative_StartIndex); }

		}
		DebugLocation(19, 1);
		} finally { DebugExitRule(GrammarFileName, "alternative"); }
		return retval;

	}
	// $ANTLR end "alternative"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:21:1: term : ( assertion | atom ( quantifier )? );
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 4);
		TraceIn("term", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int term_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> assertion7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> atom8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> quantifier9 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(21, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 4)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:2: ( assertion | atom ( quantifier )? )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case 14:
			case 35:
				{
				alt4 = 1;
				}
				break;
			case 33:
				{
				int LA4_2 = input.LA(2);

				if ((EvaluatePredicate(synpred3_JavaScriptRegExp_fragment)))
				{
					alt4 = 1;
				}
				else if ((true))
				{
					alt4 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 32:
				{
				int LA4_3 = input.LA(2);

				if ((EvaluatePredicate(synpred3_JavaScriptRegExp_fragment)))
				{
					alt4 = 1;
				}
				else if ((true))
				{
					alt4 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 18:
				{
				int LA4_4 = input.LA(2);

				if ((EvaluatePredicate(synpred3_JavaScriptRegExp_fragment)))
				{
					alt4 = 1;
				}
				else if ((true))
				{
					alt4 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 4, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 17:
				{
				int LA4_5 = input.LA(2);

				if ((EvaluatePredicate(synpred3_JavaScriptRegExp_fragment)))
				{
					alt4 = 1;
				}
				else if ((true))
				{
					alt4 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 5, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ControlEscape:
			case ControlLetter:
			case DecimalDigit:
			case DecimalDigits:
			case DecimalIntegerLiteral:
			case HexDigit:
			case HexEscapeSequence:
			case IdentityEscape:
			case NonZeroDigit:
			case UnicodeEscapeSequence:
			case 15:
			case 16:
			case 22:
			case 23:
			case 24:
			case 26:
			case 27:
			case 28:
			case 29:
			case 30:
			case 31:
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
				{
				alt4 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:4: assertion
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(22, 4);
				PushFollow(Follow._assertion_in_term90);
				assertion7=assertion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assertion7.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:23:4: atom ( quantifier )?
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(23, 4);
				PushFollow(Follow._atom_in_term95);
				atom8=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atom8.Tree);
				DebugLocation(23, 9);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:23:9: ( quantifier )?
				int alt3=2;
				try { DebugEnterSubRule(3);
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if (((LA3_0>=20 && LA3_0<=21)||LA3_0==25||LA3_0==41))
				{
					alt3 = 1;
				}
				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:23:9: quantifier
					{
					DebugLocation(23, 9);
					PushFollow(Follow._quantifier_in_term97);
					quantifier9=quantifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, quantifier9.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(3); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 4);
			LeaveRule("term", 4);
			LeaveRule_term();
			if (state.backtracking > 0) { Memoize(input, 4, term_StartIndex); }

		}
		DebugLocation(24, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_assertion();
	partial void LeaveRule_assertion();

	// $ANTLR start "assertion"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:26:1: assertion : ( '^' | '$' | '\\\\b' | '\\\\B' | '(?=' disjunction ')' | '(?!' disjunction ')' );
	[GrammarRule("assertion")]
	private AstParserRuleReturnScope<object, IToken> assertion()
	{
		EnterRule_assertion();
		EnterRule("assertion", 5);
		TraceIn("assertion", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assertion_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal10 = default(IToken);
		IToken char_literal11 = default(IToken);
		IToken string_literal12 = default(IToken);
		IToken string_literal13 = default(IToken);
		IToken string_literal14 = default(IToken);
		IToken char_literal16 = default(IToken);
		IToken string_literal17 = default(IToken);
		IToken char_literal19 = default(IToken);
		AstParserRuleReturnScope<object, IToken> disjunction15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction18 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal10_tree = default(object);
		object char_literal11_tree = default(object);
		object string_literal12_tree = default(object);
		object string_literal13_tree = default(object);
		object string_literal14_tree = default(object);
		object char_literal16_tree = default(object);
		object string_literal17_tree = default(object);
		object char_literal19_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assertion");
		DebugLocation(26, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 5)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:27:2: ( '^' | '$' | '\\\\b' | '\\\\B' | '(?=' disjunction ')' | '(?!' disjunction ')' )
			int alt5=6;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case 35:
				{
				alt5 = 1;
				}
				break;
			case 14:
				{
				alt5 = 2;
				}
				break;
			case 33:
				{
				alt5 = 3;
				}
				break;
			case 32:
				{
				alt5 = 4;
				}
				break;
			case 18:
				{
				alt5 = 5;
				}
				break;
			case 17:
				{
				alt5 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:27:4: '^'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(27, 4);
				char_literal10=(IToken)Match(input,35,Follow._35_in_assertion109); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal10_tree = (object)adaptor.Create(char_literal10);
				adaptor.AddChild(root_0, char_literal10_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:28:4: '$'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(28, 4);
				char_literal11=(IToken)Match(input,14,Follow._14_in_assertion114); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal11_tree = (object)adaptor.Create(char_literal11);
				adaptor.AddChild(root_0, char_literal11_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:29:4: '\\\\b'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(29, 4);
				string_literal12=(IToken)Match(input,33,Follow._33_in_assertion119); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal12_tree = (object)adaptor.Create(string_literal12);
				adaptor.AddChild(root_0, string_literal12_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:30:4: '\\\\B'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(30, 4);
				string_literal13=(IToken)Match(input,32,Follow._32_in_assertion124); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal13_tree = (object)adaptor.Create(string_literal13);
				adaptor.AddChild(root_0, string_literal13_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:31:4: '(?=' disjunction ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(31, 4);
				string_literal14=(IToken)Match(input,18,Follow._18_in_assertion129); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal14_tree = (object)adaptor.Create(string_literal14);
				adaptor.AddChild(root_0, string_literal14_tree);
				}
				DebugLocation(31, 10);
				PushFollow(Follow._disjunction_in_assertion131);
				disjunction15=disjunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction15.Tree);
				DebugLocation(31, 22);
				char_literal16=(IToken)Match(input,19,Follow._19_in_assertion133); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal16_tree = (object)adaptor.Create(char_literal16);
				adaptor.AddChild(root_0, char_literal16_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:32:4: '(?!' disjunction ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(32, 4);
				string_literal17=(IToken)Match(input,17,Follow._17_in_assertion138); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal17_tree = (object)adaptor.Create(string_literal17);
				adaptor.AddChild(root_0, string_literal17_tree);
				}
				DebugLocation(32, 10);
				PushFollow(Follow._disjunction_in_assertion140);
				disjunction18=disjunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction18.Tree);
				DebugLocation(32, 22);
				char_literal19=(IToken)Match(input,19,Follow._19_in_assertion142); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal19_tree = (object)adaptor.Create(char_literal19);
				adaptor.AddChild(root_0, char_literal19_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assertion", 5);
			LeaveRule("assertion", 5);
			LeaveRule_assertion();
			if (state.backtracking > 0) { Memoize(input, 5, assertion_StartIndex); }

		}
		DebugLocation(33, 1);
		} finally { DebugExitRule(GrammarFileName, "assertion"); }
		return retval;

	}
	// $ANTLR end "assertion"

	partial void EnterRule_quantifier();
	partial void LeaveRule_quantifier();

	// $ANTLR start "quantifier"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:35:1: quantifier : quantifierPrefix ( '?' )? ;
	[GrammarRule("quantifier")]
	private AstParserRuleReturnScope<object, IToken> quantifier()
	{
		EnterRule_quantifier();
		EnterRule("quantifier", 6);
		TraceIn("quantifier", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int quantifier_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal21 = default(IToken);
		AstParserRuleReturnScope<object, IToken> quantifierPrefix20 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal21_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "quantifier");
		DebugLocation(35, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 6)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:36:2: ( quantifierPrefix ( '?' )? )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:36:4: quantifierPrefix ( '?' )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(36, 4);
			PushFollow(Follow._quantifierPrefix_in_quantifier153);
			quantifierPrefix20=quantifierPrefix();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, quantifierPrefix20.Tree);
			DebugLocation(36, 21);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:36:21: ( '?' )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==25))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:36:22: '?'
				{
				DebugLocation(36, 22);
				char_literal21=(IToken)Match(input,25,Follow._25_in_quantifier156); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal21_tree = (object)adaptor.Create(char_literal21);
				adaptor.AddChild(root_0, char_literal21_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("quantifier", 6);
			LeaveRule("quantifier", 6);
			LeaveRule_quantifier();
			if (state.backtracking > 0) { Memoize(input, 6, quantifier_StartIndex); }

		}
		DebugLocation(37, 1);
		} finally { DebugExitRule(GrammarFileName, "quantifier"); }
		return retval;

	}
	// $ANTLR end "quantifier"

	partial void EnterRule_quantifierPrefix();
	partial void LeaveRule_quantifierPrefix();

	// $ANTLR start "quantifierPrefix"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:39:1: quantifierPrefix : ( '*' | '+' | '?' | '{' DecimalDigits ( ',' ( DecimalDigits )? )? '}' );
	[GrammarRule("quantifierPrefix")]
	private AstParserRuleReturnScope<object, IToken> quantifierPrefix()
	{
		EnterRule_quantifierPrefix();
		EnterRule("quantifierPrefix", 7);
		TraceIn("quantifierPrefix", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int quantifierPrefix_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal22 = default(IToken);
		IToken char_literal23 = default(IToken);
		IToken char_literal24 = default(IToken);
		IToken char_literal25 = default(IToken);
		IToken DecimalDigits26 = default(IToken);
		IToken char_literal27 = default(IToken);
		IToken DecimalDigits28 = default(IToken);
		IToken char_literal29 = default(IToken);

		object char_literal22_tree = default(object);
		object char_literal23_tree = default(object);
		object char_literal24_tree = default(object);
		object char_literal25_tree = default(object);
		object DecimalDigits26_tree = default(object);
		object char_literal27_tree = default(object);
		object DecimalDigits28_tree = default(object);
		object char_literal29_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "quantifierPrefix");
		DebugLocation(39, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 7)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:40:2: ( '*' | '+' | '?' | '{' DecimalDigits ( ',' ( DecimalDigits )? )? '}' )
			int alt9=4;
			try { DebugEnterDecision(9, false);
			switch (input.LA(1))
			{
			case 20:
				{
				alt9 = 1;
				}
				break;
			case 21:
				{
				alt9 = 2;
				}
				break;
			case 25:
				{
				alt9 = 3;
				}
				break;
			case 41:
				{
				alt9 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:40:4: '*'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(40, 4);
				char_literal22=(IToken)Match(input,20,Follow._20_in_quantifierPrefix169); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal22_tree = (object)adaptor.Create(char_literal22);
				adaptor.AddChild(root_0, char_literal22_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:41:4: '+'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(41, 4);
				char_literal23=(IToken)Match(input,21,Follow._21_in_quantifierPrefix174); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal23_tree = (object)adaptor.Create(char_literal23);
				adaptor.AddChild(root_0, char_literal23_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:42:4: '?'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(42, 4);
				char_literal24=(IToken)Match(input,25,Follow._25_in_quantifierPrefix179); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal24_tree = (object)adaptor.Create(char_literal24);
				adaptor.AddChild(root_0, char_literal24_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:43:4: '{' DecimalDigits ( ',' ( DecimalDigits )? )? '}'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(43, 4);
				char_literal25=(IToken)Match(input,41,Follow._41_in_quantifierPrefix184); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal25_tree = (object)adaptor.Create(char_literal25);
				adaptor.AddChild(root_0, char_literal25_tree);
				}
				DebugLocation(43, 8);
				DecimalDigits26=(IToken)Match(input,DecimalDigits,Follow._DecimalDigits_in_quantifierPrefix186); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DecimalDigits26_tree = (object)adaptor.Create(DecimalDigits26);
				adaptor.AddChild(root_0, DecimalDigits26_tree);
				}
				DebugLocation(43, 22);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:43:22: ( ',' ( DecimalDigits )? )?
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==22))
				{
					alt8 = 1;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:43:23: ',' ( DecimalDigits )?
					{
					DebugLocation(43, 23);
					char_literal27=(IToken)Match(input,22,Follow._22_in_quantifierPrefix189); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal27_tree = (object)adaptor.Create(char_literal27);
					adaptor.AddChild(root_0, char_literal27_tree);
					}
					DebugLocation(43, 27);
					// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:43:27: ( DecimalDigits )?
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==DecimalDigits))
					{
						alt7 = 1;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:43:28: DecimalDigits
						{
						DebugLocation(43, 28);
						DecimalDigits28=(IToken)Match(input,DecimalDigits,Follow._DecimalDigits_in_quantifierPrefix192); if (state.failed) return retval;
						if (state.backtracking == 0) {
						DecimalDigits28_tree = (object)adaptor.Create(DecimalDigits28);
						adaptor.AddChild(root_0, DecimalDigits28_tree);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(7); }


					}
					break;

				}
				} finally { DebugExitSubRule(8); }

				DebugLocation(43, 46);
				char_literal29=(IToken)Match(input,43,Follow._43_in_quantifierPrefix198); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal29_tree = (object)adaptor.Create(char_literal29);
				adaptor.AddChild(root_0, char_literal29_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("quantifierPrefix", 7);
			LeaveRule("quantifierPrefix", 7);
			LeaveRule_quantifierPrefix();
			if (state.backtracking > 0) { Memoize(input, 7, quantifierPrefix_StartIndex); }

		}
		DebugLocation(44, 1);
		} finally { DebugExitRule(GrammarFileName, "quantifierPrefix"); }
		return retval;

	}
	// $ANTLR end "quantifierPrefix"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:46:1: atom : ( patternCharacter | '.' | '\\\\' atomEscape | characterClass | '(' disjunction ')' | '(:?' disjunction ')' );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 8);
		TraceIn("atom", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int atom_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal31 = default(IToken);
		IToken char_literal32 = default(IToken);
		IToken char_literal35 = default(IToken);
		IToken char_literal37 = default(IToken);
		IToken string_literal38 = default(IToken);
		IToken char_literal40 = default(IToken);
		AstParserRuleReturnScope<object, IToken> patternCharacter30 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> atomEscape33 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> characterClass34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction36 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction39 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal31_tree = default(object);
		object char_literal32_tree = default(object);
		object char_literal35_tree = default(object);
		object char_literal37_tree = default(object);
		object string_literal38_tree = default(object);
		object char_literal40_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(46, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 8)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:47:2: ( patternCharacter | '.' | '\\\\' atomEscape | characterClass | '(' disjunction ')' | '(:?' disjunction ')' )
			int alt10=6;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case 30:
				{
				int LA10_1 = input.LA(2);

				if ((EvaluatePredicate(synpred16_JavaScriptRegExp_fragment)))
				{
					alt10 = 1;
				}
				else if ((EvaluatePredicate(synpred19_JavaScriptRegExp_fragment)))
				{
					alt10 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 10, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 24:
				{
				alt10 = 2;
				}
				break;
			case 31:
				{
				alt10 = 3;
				}
				break;
			case 29:
				{
				alt10 = 4;
				}
				break;
			case 16:
				{
				int LA10_5 = input.LA(2);

				if ((EvaluatePredicate(synpred16_JavaScriptRegExp_fragment)))
				{
					alt10 = 1;
				}
				else if ((true))
				{
					alt10 = 6;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 10, 5, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 15:
				{
				alt10 = 5;
				}
				break;
			case ControlEscape:
			case ControlLetter:
			case DecimalDigit:
			case DecimalDigits:
			case DecimalIntegerLiteral:
			case HexDigit:
			case HexEscapeSequence:
			case IdentityEscape:
			case NonZeroDigit:
			case UnicodeEscapeSequence:
			case 17:
			case 18:
			case 22:
			case 23:
			case 26:
			case 27:
			case 28:
			case 32:
			case 33:
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
				{
				alt10 = 1;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:47:4: patternCharacter
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(47, 4);
				PushFollow(Follow._patternCharacter_in_atom209);
				patternCharacter30=patternCharacter();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, patternCharacter30.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:48:4: '.'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(48, 4);
				char_literal31=(IToken)Match(input,24,Follow._24_in_atom214); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal31_tree = (object)adaptor.Create(char_literal31);
				adaptor.AddChild(root_0, char_literal31_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:49:4: '\\\\' atomEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(49, 4);
				char_literal32=(IToken)Match(input,31,Follow._31_in_atom219); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal32_tree = (object)adaptor.Create(char_literal32);
				adaptor.AddChild(root_0, char_literal32_tree);
				}
				DebugLocation(49, 9);
				PushFollow(Follow._atomEscape_in_atom221);
				atomEscape33=atomEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atomEscape33.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:50:4: characterClass
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(50, 4);
				PushFollow(Follow._characterClass_in_atom226);
				characterClass34=characterClass();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, characterClass34.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:51:4: '(' disjunction ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(51, 4);
				char_literal35=(IToken)Match(input,15,Follow._15_in_atom231); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal35_tree = (object)adaptor.Create(char_literal35);
				adaptor.AddChild(root_0, char_literal35_tree);
				}
				DebugLocation(51, 8);
				PushFollow(Follow._disjunction_in_atom233);
				disjunction36=disjunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction36.Tree);
				DebugLocation(51, 20);
				char_literal37=(IToken)Match(input,19,Follow._19_in_atom235); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal37_tree = (object)adaptor.Create(char_literal37);
				adaptor.AddChild(root_0, char_literal37_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:52:4: '(:?' disjunction ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(52, 4);
				string_literal38=(IToken)Match(input,16,Follow._16_in_atom240); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal38_tree = (object)adaptor.Create(string_literal38);
				adaptor.AddChild(root_0, string_literal38_tree);
				}
				DebugLocation(52, 10);
				PushFollow(Follow._disjunction_in_atom242);
				disjunction39=disjunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction39.Tree);
				DebugLocation(52, 22);
				char_literal40=(IToken)Match(input,19,Follow._19_in_atom244); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal40_tree = (object)adaptor.Create(char_literal40);
				adaptor.AddChild(root_0, char_literal40_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 8);
			LeaveRule("atom", 8);
			LeaveRule_atom();
			if (state.backtracking > 0) { Memoize(input, 8, atom_StartIndex); }

		}
		DebugLocation(53, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_patternCharacter();
	partial void LeaveRule_patternCharacter();

	// $ANTLR start "patternCharacter"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:55:1: patternCharacter : ~ ( '^' | '$' | '\\\\' | '.' | '*' | '+' | '?' | '(' | ')' | '[' | ']' | '{' | '}' | '|' ) ;
	[GrammarRule("patternCharacter")]
	private AstParserRuleReturnScope<object, IToken> patternCharacter()
	{
		EnterRule_patternCharacter();
		EnterRule("patternCharacter", 9);
		TraceIn("patternCharacter", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int patternCharacter_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set41 = default(IToken);

		object set41_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "patternCharacter");
		DebugLocation(55, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 9)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:56:2: (~ ( '^' | '$' | '\\\\' | '.' | '*' | '+' | '?' | '(' | ')' | '[' | ']' | '{' | '}' | '|' ) )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(56, 2);

			set41=(IToken)input.LT(1);
			if ((input.LA(1)>=ControlEscape && input.LA(1)<=UnicodeEscapeSequence)||(input.LA(1)>=16 && input.LA(1)<=18)||(input.LA(1)>=22 && input.LA(1)<=23)||(input.LA(1)>=26 && input.LA(1)<=28)||input.LA(1)==30||(input.LA(1)>=32 && input.LA(1)<=33)||(input.LA(1)>=36 && input.LA(1)<=40))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set41));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("patternCharacter", 9);
			LeaveRule("patternCharacter", 9);
			LeaveRule_patternCharacter();
			if (state.backtracking > 0) { Memoize(input, 9, patternCharacter_StartIndex); }

		}
		DebugLocation(57, 1);
		} finally { DebugExitRule(GrammarFileName, "patternCharacter"); }
		return retval;

	}
	// $ANTLR end "patternCharacter"

	partial void EnterRule_atomEscape();
	partial void LeaveRule_atomEscape();

	// $ANTLR start "atomEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:59:1: atomEscape : ( decimalEscape | characterEscape | characterClassEscape );
	[GrammarRule("atomEscape")]
	private AstParserRuleReturnScope<object, IToken> atomEscape()
	{
		EnterRule_atomEscape();
		EnterRule("atomEscape", 10);
		TraceIn("atomEscape", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int atomEscape_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> decimalEscape42 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> characterEscape43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> characterClassEscape44 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "atomEscape");
		DebugLocation(59, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 10)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:60:2: ( decimalEscape | characterEscape | characterClassEscape )
			int alt11=3;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case DecimalIntegerLiteral:
				{
				alt11 = 1;
				}
				break;
			case ControlEscape:
			case HexEscapeSequence:
			case IdentityEscape:
			case UnicodeEscapeSequence:
			case 37:
				{
				alt11 = 2;
				}
				break;
			case 26:
			case 27:
			case 28:
			case 38:
			case 39:
			case 40:
				{
				alt11 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:60:4: decimalEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(60, 4);
				PushFollow(Follow._decimalEscape_in_atomEscape295);
				decimalEscape42=decimalEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, decimalEscape42.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:61:4: characterEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(61, 4);
				PushFollow(Follow._characterEscape_in_atomEscape300);
				characterEscape43=characterEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, characterEscape43.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:62:4: characterClassEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(62, 4);
				PushFollow(Follow._characterClassEscape_in_atomEscape305);
				characterClassEscape44=characterClassEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, characterClassEscape44.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atomEscape", 10);
			LeaveRule("atomEscape", 10);
			LeaveRule_atomEscape();
			if (state.backtracking > 0) { Memoize(input, 10, atomEscape_StartIndex); }

		}
		DebugLocation(63, 1);
		} finally { DebugExitRule(GrammarFileName, "atomEscape"); }
		return retval;

	}
	// $ANTLR end "atomEscape"

	partial void EnterRule_characterEscape();
	partial void LeaveRule_characterEscape();

	// $ANTLR start "characterEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:65:1: characterEscape : ( ControlEscape | 'c' ControlLetter | HexEscapeSequence | UnicodeEscapeSequence | IdentityEscape );
	[GrammarRule("characterEscape")]
	private AstParserRuleReturnScope<object, IToken> characterEscape()
	{
		EnterRule_characterEscape();
		EnterRule("characterEscape", 11);
		TraceIn("characterEscape", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int characterEscape_StartIndex = input.Index;

		object root_0 = default(object);

		IToken ControlEscape45 = default(IToken);
		IToken char_literal46 = default(IToken);
		IToken ControlLetter47 = default(IToken);
		IToken HexEscapeSequence48 = default(IToken);
		IToken UnicodeEscapeSequence49 = default(IToken);
		IToken IdentityEscape50 = default(IToken);

		object ControlEscape45_tree = default(object);
		object char_literal46_tree = default(object);
		object ControlLetter47_tree = default(object);
		object HexEscapeSequence48_tree = default(object);
		object UnicodeEscapeSequence49_tree = default(object);
		object IdentityEscape50_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "characterEscape");
		DebugLocation(65, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 11)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:66:2: ( ControlEscape | 'c' ControlLetter | HexEscapeSequence | UnicodeEscapeSequence | IdentityEscape )
			int alt12=5;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case ControlEscape:
				{
				alt12 = 1;
				}
				break;
			case 37:
				{
				alt12 = 2;
				}
				break;
			case HexEscapeSequence:
				{
				alt12 = 3;
				}
				break;
			case UnicodeEscapeSequence:
				{
				alt12 = 4;
				}
				break;
			case IdentityEscape:
				{
				alt12 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:66:4: ControlEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(66, 4);
				ControlEscape45=(IToken)Match(input,ControlEscape,Follow._ControlEscape_in_characterEscape316); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ControlEscape45_tree = (object)adaptor.Create(ControlEscape45);
				adaptor.AddChild(root_0, ControlEscape45_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:67:4: 'c' ControlLetter
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(67, 4);
				char_literal46=(IToken)Match(input,37,Follow._37_in_characterEscape321); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal46_tree = (object)adaptor.Create(char_literal46);
				adaptor.AddChild(root_0, char_literal46_tree);
				}
				DebugLocation(67, 8);
				ControlLetter47=(IToken)Match(input,ControlLetter,Follow._ControlLetter_in_characterEscape323); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ControlLetter47_tree = (object)adaptor.Create(ControlLetter47);
				adaptor.AddChild(root_0, ControlLetter47_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:68:4: HexEscapeSequence
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(68, 4);
				HexEscapeSequence48=(IToken)Match(input,HexEscapeSequence,Follow._HexEscapeSequence_in_characterEscape328); if (state.failed) return retval;
				if (state.backtracking == 0) {
				HexEscapeSequence48_tree = (object)adaptor.Create(HexEscapeSequence48);
				adaptor.AddChild(root_0, HexEscapeSequence48_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:69:4: UnicodeEscapeSequence
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(69, 4);
				UnicodeEscapeSequence49=(IToken)Match(input,UnicodeEscapeSequence,Follow._UnicodeEscapeSequence_in_characterEscape333); if (state.failed) return retval;
				if (state.backtracking == 0) {
				UnicodeEscapeSequence49_tree = (object)adaptor.Create(UnicodeEscapeSequence49);
				adaptor.AddChild(root_0, UnicodeEscapeSequence49_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:70:4: IdentityEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(70, 4);
				IdentityEscape50=(IToken)Match(input,IdentityEscape,Follow._IdentityEscape_in_characterEscape338); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IdentityEscape50_tree = (object)adaptor.Create(IdentityEscape50);
				adaptor.AddChild(root_0, IdentityEscape50_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("characterEscape", 11);
			LeaveRule("characterEscape", 11);
			LeaveRule_characterEscape();
			if (state.backtracking > 0) { Memoize(input, 11, characterEscape_StartIndex); }

		}
		DebugLocation(71, 1);
		} finally { DebugExitRule(GrammarFileName, "characterEscape"); }
		return retval;

	}
	// $ANTLR end "characterEscape"

	partial void EnterRule_decimalEscape();
	partial void LeaveRule_decimalEscape();

	// $ANTLR start "decimalEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:101:1: decimalEscape : DecimalIntegerLiteral ;
	[GrammarRule("decimalEscape")]
	private AstParserRuleReturnScope<object, IToken> decimalEscape()
	{
		EnterRule_decimalEscape();
		EnterRule("decimalEscape", 12);
		TraceIn("decimalEscape", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int decimalEscape_StartIndex = input.Index;

		object root_0 = default(object);

		IToken DecimalIntegerLiteral51 = default(IToken);

		object DecimalIntegerLiteral51_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "decimalEscape");
		DebugLocation(101, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 12)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:102:2: ( DecimalIntegerLiteral )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:102:4: DecimalIntegerLiteral
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(102, 4);
			DecimalIntegerLiteral51=(IToken)Match(input,DecimalIntegerLiteral,Follow._DecimalIntegerLiteral_in_decimalEscape504); if (state.failed) return retval;
			if (state.backtracking == 0) {
			DecimalIntegerLiteral51_tree = (object)adaptor.Create(DecimalIntegerLiteral51);
			adaptor.AddChild(root_0, DecimalIntegerLiteral51_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decimalEscape", 12);
			LeaveRule("decimalEscape", 12);
			LeaveRule_decimalEscape();
			if (state.backtracking > 0) { Memoize(input, 12, decimalEscape_StartIndex); }

		}
		DebugLocation(103, 1);
		} finally { DebugExitRule(GrammarFileName, "decimalEscape"); }
		return retval;

	}
	// $ANTLR end "decimalEscape"

	partial void EnterRule_characterClassEscape();
	partial void LeaveRule_characterClassEscape();

	// $ANTLR start "characterClassEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:122:1: characterClassEscape : ( 'd' | 'D' | 's' | 'S' | 'w' | 'W' );
	[GrammarRule("characterClassEscape")]
	private AstParserRuleReturnScope<object, IToken> characterClassEscape()
	{
		EnterRule_characterClassEscape();
		EnterRule("characterClassEscape", 13);
		TraceIn("characterClassEscape", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int characterClassEscape_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set52 = default(IToken);

		object set52_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "characterClassEscape");
		DebugLocation(122, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 13)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:123:2: ( 'd' | 'D' | 's' | 'S' | 'w' | 'W' )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(123, 2);

			set52=(IToken)input.LT(1);
			if ((input.LA(1)>=26 && input.LA(1)<=28)||(input.LA(1)>=38 && input.LA(1)<=40))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set52));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("characterClassEscape", 13);
			LeaveRule("characterClassEscape", 13);
			LeaveRule_characterClassEscape();
			if (state.backtracking > 0) { Memoize(input, 13, characterClassEscape_StartIndex); }

		}
		DebugLocation(129, 1);
		} finally { DebugExitRule(GrammarFileName, "characterClassEscape"); }
		return retval;

	}
	// $ANTLR end "characterClassEscape"

	partial void EnterRule_characterClass();
	partial void LeaveRule_characterClass();

	// $ANTLR start "characterClass"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:131:1: characterClass : ( '[' t=~ '^' classRanges ']' | '[^' classRanges ']' );
	[GrammarRule("characterClass")]
	private AstParserRuleReturnScope<object, IToken> characterClass()
	{
		EnterRule_characterClass();
		EnterRule("characterClass", 14);
		TraceIn("characterClass", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int characterClass_StartIndex = input.Index;

		object root_0 = default(object);

		IToken t = default(IToken);
		IToken char_literal53 = default(IToken);
		IToken char_literal55 = default(IToken);
		IToken string_literal56 = default(IToken);
		IToken char_literal58 = default(IToken);
		AstParserRuleReturnScope<object, IToken> classRanges54 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classRanges57 = default(AstParserRuleReturnScope<object, IToken>);

		object t_tree = default(object);
		object char_literal53_tree = default(object);
		object char_literal55_tree = default(object);
		object string_literal56_tree = default(object);
		object char_literal58_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "characterClass");
		DebugLocation(131, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 14)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:132:2: ( '[' t=~ '^' classRanges ']' | '[^' classRanges ']' )
			int alt13=2;
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==29))
			{
				alt13 = 1;
			}
			else if ((LA13_0==30))
			{
				alt13 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:132:4: '[' t=~ '^' classRanges ']'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(132, 4);
				char_literal53=(IToken)Match(input,29,Follow._29_in_characterClass619); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal53_tree = (object)adaptor.Create(char_literal53);
				adaptor.AddChild(root_0, char_literal53_tree);
				}
				DebugLocation(132, 9);

				t=(IToken)input.LT(1);
				if ((input.LA(1)>=ControlEscape && input.LA(1)<=34)||(input.LA(1)>=36 && input.LA(1)<=43))
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(t));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(132, 15);
				PushFollow(Follow._classRanges_in_characterClass626);
				classRanges54=classRanges();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classRanges54.Tree);
				DebugLocation(132, 27);
				char_literal55=(IToken)Match(input,34,Follow._34_in_characterClass628); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal55_tree = (object)adaptor.Create(char_literal55);
				adaptor.AddChild(root_0, char_literal55_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:133:4: '[^' classRanges ']'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(133, 4);
				string_literal56=(IToken)Match(input,30,Follow._30_in_characterClass633); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal56_tree = (object)adaptor.Create(string_literal56);
				adaptor.AddChild(root_0, string_literal56_tree);
				}
				DebugLocation(133, 9);
				PushFollow(Follow._classRanges_in_characterClass635);
				classRanges57=classRanges();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classRanges57.Tree);
				DebugLocation(133, 21);
				char_literal58=(IToken)Match(input,34,Follow._34_in_characterClass637); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal58_tree = (object)adaptor.Create(char_literal58);
				adaptor.AddChild(root_0, char_literal58_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("characterClass", 14);
			LeaveRule("characterClass", 14);
			LeaveRule_characterClass();
			if (state.backtracking > 0) { Memoize(input, 14, characterClass_StartIndex); }

		}
		DebugLocation(134, 1);
		} finally { DebugExitRule(GrammarFileName, "characterClass"); }
		return retval;

	}
	// $ANTLR end "characterClass"

	partial void EnterRule_classRanges();
	partial void LeaveRule_classRanges();

	// $ANTLR start "classRanges"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:136:1: classRanges : ( nonEmptyClassRanges )? ;
	[GrammarRule("classRanges")]
	private AstParserRuleReturnScope<object, IToken> classRanges()
	{
		EnterRule_classRanges();
		EnterRule("classRanges", 15);
		TraceIn("classRanges", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int classRanges_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> nonEmptyClassRanges59 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "classRanges");
		DebugLocation(136, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 15)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:137:2: ( ( nonEmptyClassRanges )? )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:137:4: ( nonEmptyClassRanges )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(137, 4);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:137:4: ( nonEmptyClassRanges )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if (((LA14_0>=ControlEscape && LA14_0<=33)||(LA14_0>=35 && LA14_0<=43)))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:137:4: nonEmptyClassRanges
				{
				DebugLocation(137, 4);
				PushFollow(Follow._nonEmptyClassRanges_in_classRanges648);
				nonEmptyClassRanges59=nonEmptyClassRanges();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonEmptyClassRanges59.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classRanges", 15);
			LeaveRule("classRanges", 15);
			LeaveRule_classRanges();
			if (state.backtracking > 0) { Memoize(input, 15, classRanges_StartIndex); }

		}
		DebugLocation(138, 1);
		} finally { DebugExitRule(GrammarFileName, "classRanges"); }
		return retval;

	}
	// $ANTLR end "classRanges"

	partial void EnterRule_nonEmptyClassRanges();
	partial void LeaveRule_nonEmptyClassRanges();

	// $ANTLR start "nonEmptyClassRanges"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:140:1: nonEmptyClassRanges : classAtom nonEmptyClassRangesContinued ;
	[GrammarRule("nonEmptyClassRanges")]
	private AstParserRuleReturnScope<object, IToken> nonEmptyClassRanges()
	{
		EnterRule_nonEmptyClassRanges();
		EnterRule("nonEmptyClassRanges", 16);
		TraceIn("nonEmptyClassRanges", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonEmptyClassRanges_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> classAtom60 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesContinued61 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "nonEmptyClassRanges");
		DebugLocation(140, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 16)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:141:2: ( classAtom nonEmptyClassRangesContinued )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:141:4: classAtom nonEmptyClassRangesContinued
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(141, 4);
			PushFollow(Follow._classAtom_in_nonEmptyClassRanges660);
			classAtom60=classAtom();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, classAtom60.Tree);
			DebugLocation(141, 14);
			PushFollow(Follow._nonEmptyClassRangesContinued_in_nonEmptyClassRanges662);
			nonEmptyClassRangesContinued61=nonEmptyClassRangesContinued();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, nonEmptyClassRangesContinued61.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonEmptyClassRanges", 16);
			LeaveRule("nonEmptyClassRanges", 16);
			LeaveRule_nonEmptyClassRanges();
			if (state.backtracking > 0) { Memoize(input, 16, nonEmptyClassRanges_StartIndex); }

		}
		DebugLocation(142, 1);
		} finally { DebugExitRule(GrammarFileName, "nonEmptyClassRanges"); }
		return retval;

	}
	// $ANTLR end "nonEmptyClassRanges"

	partial void EnterRule_nonEmptyClassRangesContinued();
	partial void LeaveRule_nonEmptyClassRangesContinued();

	// $ANTLR start "nonEmptyClassRangesContinued"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:144:1: nonEmptyClassRangesContinued : (| nonEmptyClassRangesNoDash | '-' classAtom classRanges );
	[GrammarRule("nonEmptyClassRangesContinued")]
	private AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesContinued()
	{
		EnterRule_nonEmptyClassRangesContinued();
		EnterRule("nonEmptyClassRangesContinued", 17);
		TraceIn("nonEmptyClassRangesContinued", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonEmptyClassRangesContinued_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal63 = default(IToken);
		AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesNoDash62 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classAtom64 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classRanges65 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal63_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "nonEmptyClassRangesContinued");
		DebugLocation(144, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 17)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:145:2: (| nonEmptyClassRangesNoDash | '-' classAtom classRanges )
			int alt15=3;
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case 34:
				{
				int LA15_1 = input.LA(2);

				if ((EvaluatePredicate(synpred47_JavaScriptRegExp_fragment)))
				{
					alt15 = 1;
				}
				else if ((EvaluatePredicate(synpred48_JavaScriptRegExp_fragment)))
				{
					alt15 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case EOF:
				{
				alt15 = 1;
				}
				break;
			case 23:
				{
				int LA15_3 = input.LA(2);

				if ((EvaluatePredicate(synpred48_JavaScriptRegExp_fragment)))
				{
					alt15 = 2;
				}
				else if ((true))
				{
					alt15 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ControlEscape:
			case ControlLetter:
			case DecimalDigit:
			case DecimalDigits:
			case DecimalIntegerLiteral:
			case HexDigit:
			case HexEscapeSequence:
			case IdentityEscape:
			case NonZeroDigit:
			case UnicodeEscapeSequence:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 24:
			case 25:
			case 26:
			case 27:
			case 28:
			case 29:
			case 30:
			case 31:
			case 32:
			case 33:
			case 35:
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
			case 43:
				{
				alt15 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:2: 
				{
				root_0 = (object)adaptor.Nil();

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:4: nonEmptyClassRangesNoDash
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(146, 4);
				PushFollow(Follow._nonEmptyClassRangesNoDash_in_nonEmptyClassRangesContinued678);
				nonEmptyClassRangesNoDash62=nonEmptyClassRangesNoDash();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonEmptyClassRangesNoDash62.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:147:4: '-' classAtom classRanges
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(147, 4);
				char_literal63=(IToken)Match(input,23,Follow._23_in_nonEmptyClassRangesContinued683); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal63_tree = (object)adaptor.Create(char_literal63);
				adaptor.AddChild(root_0, char_literal63_tree);
				}
				DebugLocation(147, 8);
				PushFollow(Follow._classAtom_in_nonEmptyClassRangesContinued685);
				classAtom64=classAtom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classAtom64.Tree);
				DebugLocation(147, 18);
				PushFollow(Follow._classRanges_in_nonEmptyClassRangesContinued687);
				classRanges65=classRanges();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classRanges65.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonEmptyClassRangesContinued", 17);
			LeaveRule("nonEmptyClassRangesContinued", 17);
			LeaveRule_nonEmptyClassRangesContinued();
			if (state.backtracking > 0) { Memoize(input, 17, nonEmptyClassRangesContinued_StartIndex); }

		}
		DebugLocation(148, 1);
		} finally { DebugExitRule(GrammarFileName, "nonEmptyClassRangesContinued"); }
		return retval;

	}
	// $ANTLR end "nonEmptyClassRangesContinued"

	partial void EnterRule_nonEmptyClassRangesNoDash();
	partial void LeaveRule_nonEmptyClassRangesNoDash();

	// $ANTLR start "nonEmptyClassRangesNoDash"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:150:1: nonEmptyClassRangesNoDash : (t= '-' classAtom |t=~ '-' classAtomNoDash nonEmptyClassRangesNoDashContinued );
	[GrammarRule("nonEmptyClassRangesNoDash")]
	private AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesNoDash()
	{
		EnterRule_nonEmptyClassRangesNoDash();
		EnterRule("nonEmptyClassRangesNoDash", 18);
		TraceIn("nonEmptyClassRangesNoDash", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonEmptyClassRangesNoDash_StartIndex = input.Index;

		object root_0 = default(object);

		IToken t = default(IToken);
		AstParserRuleReturnScope<object, IToken> classAtom66 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classAtomNoDash67 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesNoDashContinued68 = default(AstParserRuleReturnScope<object, IToken>);

		object t_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "nonEmptyClassRangesNoDash");
		DebugLocation(150, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 18)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:151:2: (t= '-' classAtom |t=~ '-' classAtomNoDash nonEmptyClassRangesNoDashContinued )
			int alt16=2;
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==23))
			{
				alt16 = 1;
			}
			else if (((LA16_0>=ControlEscape && LA16_0<=22)||(LA16_0>=24 && LA16_0<=43)))
			{
				alt16 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:151:4: t= '-' classAtom
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(151, 5);
				t=(IToken)Match(input,23,Follow._23_in_nonEmptyClassRangesNoDash700); if (state.failed) return retval;
				if (state.backtracking == 0) {
				t_tree = (object)adaptor.Create(t);
				adaptor.AddChild(root_0, t_tree);
				}
				DebugLocation(151, 10);
				PushFollow(Follow._classAtom_in_nonEmptyClassRangesNoDash702);
				classAtom66=classAtom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classAtom66.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:152:4: t=~ '-' classAtomNoDash nonEmptyClassRangesNoDashContinued
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(152, 5);

				t=(IToken)input.LT(1);
				if ((input.LA(1)>=ControlEscape && input.LA(1)<=22)||(input.LA(1)>=24 && input.LA(1)<=43))
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(t));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(152, 11);
				PushFollow(Follow._classAtomNoDash_in_nonEmptyClassRangesNoDash712);
				classAtomNoDash67=classAtomNoDash();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classAtomNoDash67.Tree);
				DebugLocation(152, 27);
				PushFollow(Follow._nonEmptyClassRangesNoDashContinued_in_nonEmptyClassRangesNoDash714);
				nonEmptyClassRangesNoDashContinued68=nonEmptyClassRangesNoDashContinued();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonEmptyClassRangesNoDashContinued68.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonEmptyClassRangesNoDash", 18);
			LeaveRule("nonEmptyClassRangesNoDash", 18);
			LeaveRule_nonEmptyClassRangesNoDash();
			if (state.backtracking > 0) { Memoize(input, 18, nonEmptyClassRangesNoDash_StartIndex); }

		}
		DebugLocation(153, 1);
		} finally { DebugExitRule(GrammarFileName, "nonEmptyClassRangesNoDash"); }
		return retval;

	}
	// $ANTLR end "nonEmptyClassRangesNoDash"

	partial void EnterRule_nonEmptyClassRangesNoDashContinued();
	partial void LeaveRule_nonEmptyClassRangesNoDashContinued();

	// $ANTLR start "nonEmptyClassRangesNoDashContinued"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:155:1: nonEmptyClassRangesNoDashContinued : (| nonEmptyClassRangesNoDash | '-' classAtom classRanges );
	[GrammarRule("nonEmptyClassRangesNoDashContinued")]
	private AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesNoDashContinued()
	{
		EnterRule_nonEmptyClassRangesNoDashContinued();
		EnterRule("nonEmptyClassRangesNoDashContinued", 19);
		TraceIn("nonEmptyClassRangesNoDashContinued", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonEmptyClassRangesNoDashContinued_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal70 = default(IToken);
		AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesNoDash69 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classAtom71 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classRanges72 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal70_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "nonEmptyClassRangesNoDashContinued");
		DebugLocation(155, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 19)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:156:2: (| nonEmptyClassRangesNoDash | '-' classAtom classRanges )
			int alt17=3;
			try { DebugEnterDecision(17, false);
			switch (input.LA(1))
			{
			case 34:
				{
				int LA17_1 = input.LA(2);

				if ((EvaluatePredicate(synpred50_JavaScriptRegExp_fragment)))
				{
					alt17 = 1;
				}
				else if ((EvaluatePredicate(synpred51_JavaScriptRegExp_fragment)))
				{
					alt17 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 17, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case EOF:
				{
				alt17 = 1;
				}
				break;
			case 23:
				{
				int LA17_3 = input.LA(2);

				if ((EvaluatePredicate(synpred51_JavaScriptRegExp_fragment)))
				{
					alt17 = 2;
				}
				else if ((true))
				{
					alt17 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 17, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ControlEscape:
			case ControlLetter:
			case DecimalDigit:
			case DecimalDigits:
			case DecimalIntegerLiteral:
			case HexDigit:
			case HexEscapeSequence:
			case IdentityEscape:
			case NonZeroDigit:
			case UnicodeEscapeSequence:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 24:
			case 25:
			case 26:
			case 27:
			case 28:
			case 29:
			case 30:
			case 31:
			case 32:
			case 33:
			case 35:
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
			case 43:
				{
				alt17 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:2: 
				{
				root_0 = (object)adaptor.Nil();

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:4: nonEmptyClassRangesNoDash
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(157, 4);
				PushFollow(Follow._nonEmptyClassRangesNoDash_in_nonEmptyClassRangesNoDashContinued730);
				nonEmptyClassRangesNoDash69=nonEmptyClassRangesNoDash();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonEmptyClassRangesNoDash69.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:158:4: '-' classAtom classRanges
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(158, 4);
				char_literal70=(IToken)Match(input,23,Follow._23_in_nonEmptyClassRangesNoDashContinued735); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal70_tree = (object)adaptor.Create(char_literal70);
				adaptor.AddChild(root_0, char_literal70_tree);
				}
				DebugLocation(158, 8);
				PushFollow(Follow._classAtom_in_nonEmptyClassRangesNoDashContinued737);
				classAtom71=classAtom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classAtom71.Tree);
				DebugLocation(158, 18);
				PushFollow(Follow._classRanges_in_nonEmptyClassRangesNoDashContinued739);
				classRanges72=classRanges();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classRanges72.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonEmptyClassRangesNoDashContinued", 19);
			LeaveRule("nonEmptyClassRangesNoDashContinued", 19);
			LeaveRule_nonEmptyClassRangesNoDashContinued();
			if (state.backtracking > 0) { Memoize(input, 19, nonEmptyClassRangesNoDashContinued_StartIndex); }

		}
		DebugLocation(159, 1);
		} finally { DebugExitRule(GrammarFileName, "nonEmptyClassRangesNoDashContinued"); }
		return retval;

	}
	// $ANTLR end "nonEmptyClassRangesNoDashContinued"

	partial void EnterRule_classAtom();
	partial void LeaveRule_classAtom();

	// $ANTLR start "classAtom"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:161:1: classAtom : ( '-' | classAtomNoDash );
	[GrammarRule("classAtom")]
	private AstParserRuleReturnScope<object, IToken> classAtom()
	{
		EnterRule_classAtom();
		EnterRule("classAtom", 20);
		TraceIn("classAtom", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int classAtom_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal73 = default(IToken);
		AstParserRuleReturnScope<object, IToken> classAtomNoDash74 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal73_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "classAtom");
		DebugLocation(161, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 20)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:162:2: ( '-' | classAtomNoDash )
			int alt18=2;
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==23))
			{
				alt18 = 1;
			}
			else if (((LA18_0>=ControlEscape && LA18_0<=22)||(LA18_0>=24 && LA18_0<=33)||(LA18_0>=35 && LA18_0<=43)))
			{
				alt18 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 18, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:162:4: '-'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(162, 4);
				char_literal73=(IToken)Match(input,23,Follow._23_in_classAtom750); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal73_tree = (object)adaptor.Create(char_literal73);
				adaptor.AddChild(root_0, char_literal73_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:163:4: classAtomNoDash
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(163, 4);
				PushFollow(Follow._classAtomNoDash_in_classAtom755);
				classAtomNoDash74=classAtomNoDash();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classAtomNoDash74.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classAtom", 20);
			LeaveRule("classAtom", 20);
			LeaveRule_classAtom();
			if (state.backtracking > 0) { Memoize(input, 20, classAtom_StartIndex); }

		}
		DebugLocation(164, 1);
		} finally { DebugExitRule(GrammarFileName, "classAtom"); }
		return retval;

	}
	// $ANTLR end "classAtom"

	partial void EnterRule_classAtomNoDash();
	partial void LeaveRule_classAtomNoDash();

	// $ANTLR start "classAtomNoDash"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:166:1: classAtomNoDash : (~ ( '\\\\' | ']' | '-' ) | '\\\\' classEscape );
	[GrammarRule("classAtomNoDash")]
	private AstParserRuleReturnScope<object, IToken> classAtomNoDash()
	{
		EnterRule_classAtomNoDash();
		EnterRule("classAtomNoDash", 21);
		TraceIn("classAtomNoDash", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int classAtomNoDash_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set75 = default(IToken);
		IToken char_literal76 = default(IToken);
		AstParserRuleReturnScope<object, IToken> classEscape77 = default(AstParserRuleReturnScope<object, IToken>);

		object set75_tree = default(object);
		object char_literal76_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "classAtomNoDash");
		DebugLocation(166, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 21)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:167:2: (~ ( '\\\\' | ']' | '-' ) | '\\\\' classEscape )
			int alt19=2;
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if (((LA19_0>=ControlEscape && LA19_0<=22)||(LA19_0>=24 && LA19_0<=30)||(LA19_0>=32 && LA19_0<=33)||(LA19_0>=35 && LA19_0<=43)))
			{
				alt19 = 1;
			}
			else if ((LA19_0==31))
			{
				alt19 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:167:4: ~ ( '\\\\' | ']' | '-' )
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(167, 4);

				set75=(IToken)input.LT(1);
				if ((input.LA(1)>=ControlEscape && input.LA(1)<=22)||(input.LA(1)>=24 && input.LA(1)<=30)||(input.LA(1)>=32 && input.LA(1)<=33)||(input.LA(1)>=35 && input.LA(1)<=43))
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set75));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:168:4: '\\\\' classEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(168, 4);
				char_literal76=(IToken)Match(input,31,Follow._31_in_classAtomNoDash782); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal76_tree = (object)adaptor.Create(char_literal76);
				adaptor.AddChild(root_0, char_literal76_tree);
				}
				DebugLocation(168, 9);
				PushFollow(Follow._classEscape_in_classAtomNoDash784);
				classEscape77=classEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classEscape77.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classAtomNoDash", 21);
			LeaveRule("classAtomNoDash", 21);
			LeaveRule_classAtomNoDash();
			if (state.backtracking > 0) { Memoize(input, 21, classAtomNoDash_StartIndex); }

		}
		DebugLocation(169, 1);
		} finally { DebugExitRule(GrammarFileName, "classAtomNoDash"); }
		return retval;

	}
	// $ANTLR end "classAtomNoDash"

	partial void EnterRule_classEscape();
	partial void LeaveRule_classEscape();

	// $ANTLR start "classEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:171:1: classEscape : ( decimalEscape | 'b' | characterEscape | characterClassEscape );
	[GrammarRule("classEscape")]
	private AstParserRuleReturnScope<object, IToken> classEscape()
	{
		EnterRule_classEscape();
		EnterRule("classEscape", 22);
		TraceIn("classEscape", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int classEscape_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal79 = default(IToken);
		AstParserRuleReturnScope<object, IToken> decimalEscape78 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> characterEscape80 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> characterClassEscape81 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal79_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "classEscape");
		DebugLocation(171, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 22)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:172:2: ( decimalEscape | 'b' | characterEscape | characterClassEscape )
			int alt20=4;
			try { DebugEnterDecision(20, false);
			switch (input.LA(1))
			{
			case DecimalIntegerLiteral:
				{
				alt20 = 1;
				}
				break;
			case 36:
				{
				alt20 = 2;
				}
				break;
			case ControlEscape:
			case HexEscapeSequence:
			case IdentityEscape:
			case UnicodeEscapeSequence:
			case 37:
				{
				alt20 = 3;
				}
				break;
			case 26:
			case 27:
			case 28:
			case 38:
			case 39:
			case 40:
				{
				alt20 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:172:4: decimalEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(172, 4);
				PushFollow(Follow._decimalEscape_in_classEscape795);
				decimalEscape78=decimalEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, decimalEscape78.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:173:4: 'b'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(173, 4);
				char_literal79=(IToken)Match(input,36,Follow._36_in_classEscape800); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal79_tree = (object)adaptor.Create(char_literal79);
				adaptor.AddChild(root_0, char_literal79_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:174:4: characterEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(174, 4);
				PushFollow(Follow._characterEscape_in_classEscape805);
				characterEscape80=characterEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, characterEscape80.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:175:4: characterClassEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(175, 4);
				PushFollow(Follow._characterClassEscape_in_classEscape810);
				characterClassEscape81=characterClassEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, characterClassEscape81.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classEscape", 22);
			LeaveRule("classEscape", 22);
			LeaveRule_classEscape();
			if (state.backtracking > 0) { Memoize(input, 22, classEscape_StartIndex); }

		}
		DebugLocation(176, 1);
		} finally { DebugExitRule(GrammarFileName, "classEscape"); }
		return retval;

	}
	// $ANTLR end "classEscape"

	partial void EnterRule_synpred3_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred3_JavaScriptRegExp_fragment();

	// $ANTLR start synpred3_JavaScriptRegExp
	public void synpred3_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred3_JavaScriptRegExp_fragment();
		EnterRule("synpred3_JavaScriptRegExp_fragment", 25);
		TraceIn("synpred3_JavaScriptRegExp_fragment", 25);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:4: ( assertion )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:4: assertion
			{
			DebugLocation(22, 4);
			PushFollow(Follow._assertion_in_synpred3_JavaScriptRegExp90);
			assertion();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_JavaScriptRegExp_fragment", 25);
			LeaveRule("synpred3_JavaScriptRegExp_fragment", 25);
			LeaveRule_synpred3_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred3_JavaScriptRegExp

	partial void EnterRule_synpred16_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred16_JavaScriptRegExp_fragment();

	// $ANTLR start synpred16_JavaScriptRegExp
	public void synpred16_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred16_JavaScriptRegExp_fragment();
		EnterRule("synpred16_JavaScriptRegExp_fragment", 38);
		TraceIn("synpred16_JavaScriptRegExp_fragment", 38);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:47:4: ( patternCharacter )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:47:4: patternCharacter
			{
			DebugLocation(47, 4);
			PushFollow(Follow._patternCharacter_in_synpred16_JavaScriptRegExp209);
			patternCharacter();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred16_JavaScriptRegExp_fragment", 38);
			LeaveRule("synpred16_JavaScriptRegExp_fragment", 38);
			LeaveRule_synpred16_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred16_JavaScriptRegExp

	partial void EnterRule_synpred19_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred19_JavaScriptRegExp_fragment();

	// $ANTLR start synpred19_JavaScriptRegExp
	public void synpred19_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred19_JavaScriptRegExp_fragment();
		EnterRule("synpred19_JavaScriptRegExp_fragment", 41);
		TraceIn("synpred19_JavaScriptRegExp_fragment", 41);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:50:4: ( characterClass )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:50:4: characterClass
			{
			DebugLocation(50, 4);
			PushFollow(Follow._characterClass_in_synpred19_JavaScriptRegExp226);
			characterClass();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred19_JavaScriptRegExp_fragment", 41);
			LeaveRule("synpred19_JavaScriptRegExp_fragment", 41);
			LeaveRule_synpred19_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred19_JavaScriptRegExp

	partial void EnterRule_synpred47_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred47_JavaScriptRegExp_fragment();

	// $ANTLR start synpred47_JavaScriptRegExp
	public void synpred47_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred47_JavaScriptRegExp_fragment();
		EnterRule("synpred47_JavaScriptRegExp_fragment", 69);
		TraceIn("synpred47_JavaScriptRegExp_fragment", 69);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:2: ()
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:2: 
			{
			}

		}
		finally
		{
			TraceOut("synpred47_JavaScriptRegExp_fragment", 69);
			LeaveRule("synpred47_JavaScriptRegExp_fragment", 69);
			LeaveRule_synpred47_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred47_JavaScriptRegExp

	partial void EnterRule_synpred48_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred48_JavaScriptRegExp_fragment();

	// $ANTLR start synpred48_JavaScriptRegExp
	public void synpred48_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred48_JavaScriptRegExp_fragment();
		EnterRule("synpred48_JavaScriptRegExp_fragment", 70);
		TraceIn("synpred48_JavaScriptRegExp_fragment", 70);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:4: ( nonEmptyClassRangesNoDash )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:4: nonEmptyClassRangesNoDash
			{
			DebugLocation(146, 4);
			PushFollow(Follow._nonEmptyClassRangesNoDash_in_synpred48_JavaScriptRegExp678);
			nonEmptyClassRangesNoDash();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred48_JavaScriptRegExp_fragment", 70);
			LeaveRule("synpred48_JavaScriptRegExp_fragment", 70);
			LeaveRule_synpred48_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred48_JavaScriptRegExp

	partial void EnterRule_synpred50_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred50_JavaScriptRegExp_fragment();

	// $ANTLR start synpred50_JavaScriptRegExp
	public void synpred50_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred50_JavaScriptRegExp_fragment();
		EnterRule("synpred50_JavaScriptRegExp_fragment", 72);
		TraceIn("synpred50_JavaScriptRegExp_fragment", 72);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:2: ()
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:2: 
			{
			}

		}
		finally
		{
			TraceOut("synpred50_JavaScriptRegExp_fragment", 72);
			LeaveRule("synpred50_JavaScriptRegExp_fragment", 72);
			LeaveRule_synpred50_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred50_JavaScriptRegExp

	partial void EnterRule_synpred51_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred51_JavaScriptRegExp_fragment();

	// $ANTLR start synpred51_JavaScriptRegExp
	public void synpred51_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred51_JavaScriptRegExp_fragment();
		EnterRule("synpred51_JavaScriptRegExp_fragment", 73);
		TraceIn("synpred51_JavaScriptRegExp_fragment", 73);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:4: ( nonEmptyClassRangesNoDash )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:4: nonEmptyClassRangesNoDash
			{
			DebugLocation(157, 4);
			PushFollow(Follow._nonEmptyClassRangesNoDash_in_synpred51_JavaScriptRegExp730);
			nonEmptyClassRangesNoDash();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred51_JavaScriptRegExp_fragment", 73);
			LeaveRule("synpred51_JavaScriptRegExp_fragment", 73);
			LeaveRule_synpred51_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred51_JavaScriptRegExp
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _disjunction_in_pattern47 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_pattern49 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alternative_in_disjunction60 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _42_in_disjunction63 = new BitSet(new ulong[]{0x5FBFDC7FFF0UL});
		public static readonly BitSet _disjunction_in_disjunction65 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_alternative78 = new BitSet(new ulong[]{0x1FBFDC7FFF2UL});
		public static readonly BitSet _assertion_in_term90 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_term95 = new BitSet(new ulong[]{0x20002300002UL});
		public static readonly BitSet _quantifier_in_term97 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _35_in_assertion109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _14_in_assertion114 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _33_in_assertion119 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _32_in_assertion124 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _18_in_assertion129 = new BitSet(new ulong[]{0x5FBFDC7FFF0UL});
		public static readonly BitSet _disjunction_in_assertion131 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _19_in_assertion133 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _17_in_assertion138 = new BitSet(new ulong[]{0x5FBFDC7FFF0UL});
		public static readonly BitSet _disjunction_in_assertion140 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _19_in_assertion142 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quantifierPrefix_in_quantifier153 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _25_in_quantifier156 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _20_in_quantifierPrefix169 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _21_in_quantifierPrefix174 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _25_in_quantifierPrefix179 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _41_in_quantifierPrefix184 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _DecimalDigits_in_quantifierPrefix186 = new BitSet(new ulong[]{0x80000400000UL});
		public static readonly BitSet _22_in_quantifierPrefix189 = new BitSet(new ulong[]{0x80000000080UL});
		public static readonly BitSet _DecimalDigits_in_quantifierPrefix192 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_quantifierPrefix198 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _patternCharacter_in_atom209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _24_in_atom214 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _31_in_atom219 = new BitSet(new ulong[]{0x1E01C002D10UL});
		public static readonly BitSet _atomEscape_in_atom221 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterClass_in_atom226 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _15_in_atom231 = new BitSet(new ulong[]{0x5FBFDC7FFF0UL});
		public static readonly BitSet _disjunction_in_atom233 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _19_in_atom235 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _16_in_atom240 = new BitSet(new ulong[]{0x5FBFDC7FFF0UL});
		public static readonly BitSet _disjunction_in_atom242 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _19_in_atom244 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _decimalEscape_in_atomEscape295 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterEscape_in_atomEscape300 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterClassEscape_in_atomEscape305 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ControlEscape_in_characterEscape316 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _37_in_characterEscape321 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ControlLetter_in_characterEscape323 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HexEscapeSequence_in_characterEscape328 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _UnicodeEscapeSequence_in_characterEscape333 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IdentityEscape_in_characterEscape338 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DecimalIntegerLiteral_in_decimalEscape504 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _29_in_characterClass619 = new BitSet(new ulong[]{0xFF7FFFFFFF0UL});
		public static readonly BitSet _set_in_characterClass623 = new BitSet(new ulong[]{0xFFFFFFFFFF0UL});
		public static readonly BitSet _classRanges_in_characterClass626 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_characterClass628 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _30_in_characterClass633 = new BitSet(new ulong[]{0xFFFFFFFFFF0UL});
		public static readonly BitSet _classRanges_in_characterClass635 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_characterClass637 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonEmptyClassRanges_in_classRanges648 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classAtom_in_nonEmptyClassRanges660 = new BitSet(new ulong[]{0xFFFFFFFFFF0UL});
		public static readonly BitSet _nonEmptyClassRangesContinued_in_nonEmptyClassRanges662 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonEmptyClassRangesNoDash_in_nonEmptyClassRangesContinued678 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _23_in_nonEmptyClassRangesContinued683 = new BitSet(new ulong[]{0xFFBFFFFFFF0UL});
		public static readonly BitSet _classAtom_in_nonEmptyClassRangesContinued685 = new BitSet(new ulong[]{0xFFBFFFFFFF0UL});
		public static readonly BitSet _classRanges_in_nonEmptyClassRangesContinued687 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _23_in_nonEmptyClassRangesNoDash700 = new BitSet(new ulong[]{0xFFBFFFFFFF0UL});
		public static readonly BitSet _classAtom_in_nonEmptyClassRangesNoDash702 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_nonEmptyClassRangesNoDash709 = new BitSet(new ulong[]{0xFFBFF7FFFF0UL});
		public static readonly BitSet _classAtomNoDash_in_nonEmptyClassRangesNoDash712 = new BitSet(new ulong[]{0xFFFFFFFFFF0UL});
		public static readonly BitSet _nonEmptyClassRangesNoDashContinued_in_nonEmptyClassRangesNoDash714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonEmptyClassRangesNoDash_in_nonEmptyClassRangesNoDashContinued730 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _23_in_nonEmptyClassRangesNoDashContinued735 = new BitSet(new ulong[]{0xFFBFFFFFFF0UL});
		public static readonly BitSet _classAtom_in_nonEmptyClassRangesNoDashContinued737 = new BitSet(new ulong[]{0xFFBFFFFFFF0UL});
		public static readonly BitSet _classRanges_in_nonEmptyClassRangesNoDashContinued739 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _23_in_classAtom750 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classAtomNoDash_in_classAtom755 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_classAtomNoDash766 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _31_in_classAtomNoDash782 = new BitSet(new ulong[]{0x1F01C002D10UL});
		public static readonly BitSet _classEscape_in_classAtomNoDash784 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _decimalEscape_in_classEscape795 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _36_in_classEscape800 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterEscape_in_classEscape805 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterClassEscape_in_classEscape810 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assertion_in_synpred3_JavaScriptRegExp90 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _patternCharacter_in_synpred16_JavaScriptRegExp209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterClass_in_synpred19_JavaScriptRegExp226 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonEmptyClassRangesNoDash_in_synpred48_JavaScriptRegExp678 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonEmptyClassRangesNoDash_in_synpred51_JavaScriptRegExp730 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
