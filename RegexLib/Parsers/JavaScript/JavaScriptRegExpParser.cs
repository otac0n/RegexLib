//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g 2012-06-20 20:09:12

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class JavaScriptRegExpParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "'$'", "'('", "'(:?'", "'(?!'", "'(?='", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'0'", "'1'", "'9'", "'?'", "'A'", "'D'", "'F'", "'S'", "'W'", "'Z'", "'['", "'[^'", "'\\\\'", "'\\\\B'", "'\\\\b'", "']'", "'^'", "'a'", "'b'", "'c'", "'d'", "'f'", "'n'", "'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'", "'z'", "'{'", "'|'", "'}'"
	};
	public const int EOF=-1;
	public const int T__4=4;
	public const int T__5=5;
	public const int T__6=6;
	public const int T__7=7;
	public const int T__8=8;
	public const int T__9=9;
	public const int T__10=10;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int T__18=18;
	public const int T__19=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int T__29=29;
	public const int T__30=30;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;

	public JavaScriptRegExpParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public JavaScriptRegExpParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[100+1];


		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return JavaScriptRegExpParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_pattern();
	partial void LeaveRule_pattern();

	// $ANTLR start "pattern"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:9:1: pattern : disjunction EOF ;
	[GrammarRule("pattern")]
	private AstParserRuleReturnScope<object, IToken> pattern()
	{
		EnterRule_pattern();
		EnterRule("pattern", 1);
		TraceIn("pattern", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int pattern_StartIndex = input.Index;

		object root_0 = default(object);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> disjunction1 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF2_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "pattern");
		DebugLocation(9, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 1)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:10:2: ( disjunction EOF )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:10:4: disjunction EOF
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(10, 4);
			PushFollow(Follow._disjunction_in_pattern47);
			disjunction1=disjunction();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction1.Tree);
			DebugLocation(10, 16);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_pattern49); if (state.failed) return retval;
			if (state.backtracking == 0) {
			EOF2_tree = (object)adaptor.Create(EOF2);
			adaptor.AddChild(root_0, EOF2_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("pattern", 1);
			LeaveRule("pattern", 1);
			LeaveRule_pattern();
			if (state.backtracking > 0) { Memoize(input, 1, pattern_StartIndex); }

		}
		DebugLocation(11, 1);
		} finally { DebugExitRule(GrammarFileName, "pattern"); }
		return retval;

	}
	// $ANTLR end "pattern"

	partial void EnterRule_disjunction();
	partial void LeaveRule_disjunction();

	// $ANTLR start "disjunction"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:13:1: disjunction : alternative ( '|' disjunction )? ;
	[GrammarRule("disjunction")]
	private AstParserRuleReturnScope<object, IToken> disjunction()
	{
		EnterRule_disjunction();
		EnterRule("disjunction", 2);
		TraceIn("disjunction", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int disjunction_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal4 = default(IToken);
		AstParserRuleReturnScope<object, IToken> alternative3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction5 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal4_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "disjunction");
		DebugLocation(13, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 2)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:14:2: ( alternative ( '|' disjunction )? )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:14:4: alternative ( '|' disjunction )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(14, 4);
			PushFollow(Follow._alternative_in_disjunction60);
			alternative3=alternative();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, alternative3.Tree);
			DebugLocation(14, 16);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:14:16: ( '|' disjunction )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==47))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:14:17: '|' disjunction
				{
				DebugLocation(14, 17);
				char_literal4=(IToken)Match(input,47,Follow._47_in_disjunction63); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal4_tree = (object)adaptor.Create(char_literal4);
				adaptor.AddChild(root_0, char_literal4_tree);
				}
				DebugLocation(14, 21);
				PushFollow(Follow._disjunction_in_disjunction65);
				disjunction5=disjunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction5.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("disjunction", 2);
			LeaveRule("disjunction", 2);
			LeaveRule_disjunction();
			if (state.backtracking > 0) { Memoize(input, 2, disjunction_StartIndex); }

		}
		DebugLocation(15, 1);
		} finally { DebugExitRule(GrammarFileName, "disjunction"); }
		return retval;

	}
	// $ANTLR end "disjunction"

	partial void EnterRule_alternative();
	partial void LeaveRule_alternative();

	// $ANTLR start "alternative"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:17:1: alternative : ( term )* ;
	[GrammarRule("alternative")]
	private AstParserRuleReturnScope<object, IToken> alternative()
	{
		EnterRule_alternative();
		EnterRule("alternative", 3);
		TraceIn("alternative", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int alternative_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> term6 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "alternative");
		DebugLocation(17, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 3)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:18:2: ( ( term )* )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:18:4: ( term )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(18, 4);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:18:4: ( term )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if (((LA2_0>=4 && LA2_0<=8)||(LA2_0>=12 && LA2_0<=17)||(LA2_0>=19 && LA2_0<=29)||(LA2_0>=31 && LA2_0<=45)))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:18:4: term
					{
					DebugLocation(18, 4);
					PushFollow(Follow._term_in_alternative78);
					term6=term();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, term6.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("alternative", 3);
			LeaveRule("alternative", 3);
			LeaveRule_alternative();
			if (state.backtracking > 0) { Memoize(input, 3, alternative_StartIndex); }

		}
		DebugLocation(19, 1);
		} finally { DebugExitRule(GrammarFileName, "alternative"); }
		return retval;

	}
	// $ANTLR end "alternative"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:21:1: term : ( assertion | atom ( quantifier )? );
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 4);
		TraceIn("term", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int term_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> assertion7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> atom8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> quantifier9 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(21, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 4)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:2: ( assertion | atom ( quantifier )? )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case 4:
			case 31:
				{
				alt4 = 1;
				}
				break;
			case 29:
				{
				int LA4_2 = input.LA(2);

				if ((EvaluatePredicate(synpred3_JavaScriptRegExp_fragment)))
				{
					alt4 = 1;
				}
				else if ((true))
				{
					alt4 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 28:
				{
				int LA4_3 = input.LA(2);

				if ((EvaluatePredicate(synpred3_JavaScriptRegExp_fragment)))
				{
					alt4 = 1;
				}
				else if ((true))
				{
					alt4 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 8:
				{
				int LA4_4 = input.LA(2);

				if ((EvaluatePredicate(synpred3_JavaScriptRegExp_fragment)))
				{
					alt4 = 1;
				}
				else if ((true))
				{
					alt4 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 4, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 7:
				{
				int LA4_5 = input.LA(2);

				if ((EvaluatePredicate(synpred3_JavaScriptRegExp_fragment)))
				{
					alt4 = 1;
				}
				else if ((true))
				{
					alt4 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 5, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 5:
			case 6:
			case 12:
			case 13:
			case 14:
			case 15:
			case 16:
			case 17:
			case 19:
			case 20:
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27:
			case 32:
			case 33:
			case 34:
			case 35:
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
			case 43:
			case 44:
			case 45:
				{
				alt4 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:4: assertion
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(22, 4);
				PushFollow(Follow._assertion_in_term90);
				assertion7=assertion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assertion7.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:23:4: atom ( quantifier )?
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(23, 4);
				PushFollow(Follow._atom_in_term95);
				atom8=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atom8.Tree);
				DebugLocation(23, 9);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:23:9: ( quantifier )?
				int alt3=2;
				try { DebugEnterSubRule(3);
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if (((LA3_0>=10 && LA3_0<=11)||LA3_0==18||LA3_0==46))
				{
					alt3 = 1;
				}
				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:23:9: quantifier
					{
					DebugLocation(23, 9);
					PushFollow(Follow._quantifier_in_term97);
					quantifier9=quantifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, quantifier9.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(3); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 4);
			LeaveRule("term", 4);
			LeaveRule_term();
			if (state.backtracking > 0) { Memoize(input, 4, term_StartIndex); }

		}
		DebugLocation(24, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_assertion();
	partial void LeaveRule_assertion();

	// $ANTLR start "assertion"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:26:1: assertion : ( '^' | '$' | '\\\\b' | '\\\\B' | '(?=' disjunction ')' | '(?!' disjunction ')' );
	[GrammarRule("assertion")]
	private AstParserRuleReturnScope<object, IToken> assertion()
	{
		EnterRule_assertion();
		EnterRule("assertion", 5);
		TraceIn("assertion", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assertion_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal10 = default(IToken);
		IToken char_literal11 = default(IToken);
		IToken string_literal12 = default(IToken);
		IToken string_literal13 = default(IToken);
		IToken string_literal14 = default(IToken);
		IToken char_literal16 = default(IToken);
		IToken string_literal17 = default(IToken);
		IToken char_literal19 = default(IToken);
		AstParserRuleReturnScope<object, IToken> disjunction15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction18 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal10_tree = default(object);
		object char_literal11_tree = default(object);
		object string_literal12_tree = default(object);
		object string_literal13_tree = default(object);
		object string_literal14_tree = default(object);
		object char_literal16_tree = default(object);
		object string_literal17_tree = default(object);
		object char_literal19_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assertion");
		DebugLocation(26, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 5)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:27:2: ( '^' | '$' | '\\\\b' | '\\\\B' | '(?=' disjunction ')' | '(?!' disjunction ')' )
			int alt5=6;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case 31:
				{
				alt5 = 1;
				}
				break;
			case 4:
				{
				alt5 = 2;
				}
				break;
			case 29:
				{
				alt5 = 3;
				}
				break;
			case 28:
				{
				alt5 = 4;
				}
				break;
			case 8:
				{
				alt5 = 5;
				}
				break;
			case 7:
				{
				alt5 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:27:4: '^'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(27, 4);
				char_literal10=(IToken)Match(input,31,Follow._31_in_assertion109); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal10_tree = (object)adaptor.Create(char_literal10);
				adaptor.AddChild(root_0, char_literal10_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:28:4: '$'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(28, 4);
				char_literal11=(IToken)Match(input,4,Follow._4_in_assertion114); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal11_tree = (object)adaptor.Create(char_literal11);
				adaptor.AddChild(root_0, char_literal11_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:29:4: '\\\\b'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(29, 4);
				string_literal12=(IToken)Match(input,29,Follow._29_in_assertion119); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal12_tree = (object)adaptor.Create(string_literal12);
				adaptor.AddChild(root_0, string_literal12_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:30:4: '\\\\B'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(30, 4);
				string_literal13=(IToken)Match(input,28,Follow._28_in_assertion124); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal13_tree = (object)adaptor.Create(string_literal13);
				adaptor.AddChild(root_0, string_literal13_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:31:4: '(?=' disjunction ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(31, 4);
				string_literal14=(IToken)Match(input,8,Follow._8_in_assertion129); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal14_tree = (object)adaptor.Create(string_literal14);
				adaptor.AddChild(root_0, string_literal14_tree);
				}
				DebugLocation(31, 10);
				PushFollow(Follow._disjunction_in_assertion131);
				disjunction15=disjunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction15.Tree);
				DebugLocation(31, 22);
				char_literal16=(IToken)Match(input,9,Follow._9_in_assertion133); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal16_tree = (object)adaptor.Create(char_literal16);
				adaptor.AddChild(root_0, char_literal16_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:32:4: '(?!' disjunction ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(32, 4);
				string_literal17=(IToken)Match(input,7,Follow._7_in_assertion138); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal17_tree = (object)adaptor.Create(string_literal17);
				adaptor.AddChild(root_0, string_literal17_tree);
				}
				DebugLocation(32, 10);
				PushFollow(Follow._disjunction_in_assertion140);
				disjunction18=disjunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction18.Tree);
				DebugLocation(32, 22);
				char_literal19=(IToken)Match(input,9,Follow._9_in_assertion142); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal19_tree = (object)adaptor.Create(char_literal19);
				adaptor.AddChild(root_0, char_literal19_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assertion", 5);
			LeaveRule("assertion", 5);
			LeaveRule_assertion();
			if (state.backtracking > 0) { Memoize(input, 5, assertion_StartIndex); }

		}
		DebugLocation(33, 1);
		} finally { DebugExitRule(GrammarFileName, "assertion"); }
		return retval;

	}
	// $ANTLR end "assertion"

	partial void EnterRule_quantifier();
	partial void LeaveRule_quantifier();

	// $ANTLR start "quantifier"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:35:1: quantifier : quantifierPrefix ( '?' )? ;
	[GrammarRule("quantifier")]
	private AstParserRuleReturnScope<object, IToken> quantifier()
	{
		EnterRule_quantifier();
		EnterRule("quantifier", 6);
		TraceIn("quantifier", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int quantifier_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal21 = default(IToken);
		AstParserRuleReturnScope<object, IToken> quantifierPrefix20 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal21_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "quantifier");
		DebugLocation(35, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 6)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:36:2: ( quantifierPrefix ( '?' )? )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:36:4: quantifierPrefix ( '?' )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(36, 4);
			PushFollow(Follow._quantifierPrefix_in_quantifier153);
			quantifierPrefix20=quantifierPrefix();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, quantifierPrefix20.Tree);
			DebugLocation(36, 21);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:36:21: ( '?' )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==18))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:36:22: '?'
				{
				DebugLocation(36, 22);
				char_literal21=(IToken)Match(input,18,Follow._18_in_quantifier156); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal21_tree = (object)adaptor.Create(char_literal21);
				adaptor.AddChild(root_0, char_literal21_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("quantifier", 6);
			LeaveRule("quantifier", 6);
			LeaveRule_quantifier();
			if (state.backtracking > 0) { Memoize(input, 6, quantifier_StartIndex); }

		}
		DebugLocation(37, 1);
		} finally { DebugExitRule(GrammarFileName, "quantifier"); }
		return retval;

	}
	// $ANTLR end "quantifier"

	partial void EnterRule_quantifierPrefix();
	partial void LeaveRule_quantifierPrefix();

	// $ANTLR start "quantifierPrefix"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:39:1: quantifierPrefix : ( '*' | '+' | '?' | '{' decimalDigits ( ',' ( decimalDigits )? )? '}' );
	[GrammarRule("quantifierPrefix")]
	private AstParserRuleReturnScope<object, IToken> quantifierPrefix()
	{
		EnterRule_quantifierPrefix();
		EnterRule("quantifierPrefix", 7);
		TraceIn("quantifierPrefix", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int quantifierPrefix_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal22 = default(IToken);
		IToken char_literal23 = default(IToken);
		IToken char_literal24 = default(IToken);
		IToken char_literal25 = default(IToken);
		IToken char_literal27 = default(IToken);
		IToken char_literal29 = default(IToken);
		AstParserRuleReturnScope<object, IToken> decimalDigits26 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> decimalDigits28 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal22_tree = default(object);
		object char_literal23_tree = default(object);
		object char_literal24_tree = default(object);
		object char_literal25_tree = default(object);
		object char_literal27_tree = default(object);
		object char_literal29_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "quantifierPrefix");
		DebugLocation(39, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 7)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:40:2: ( '*' | '+' | '?' | '{' decimalDigits ( ',' ( decimalDigits )? )? '}' )
			int alt9=4;
			try { DebugEnterDecision(9, false);
			switch (input.LA(1))
			{
			case 10:
				{
				alt9 = 1;
				}
				break;
			case 11:
				{
				alt9 = 2;
				}
				break;
			case 18:
				{
				alt9 = 3;
				}
				break;
			case 46:
				{
				alt9 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:40:4: '*'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(40, 4);
				char_literal22=(IToken)Match(input,10,Follow._10_in_quantifierPrefix169); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal22_tree = (object)adaptor.Create(char_literal22);
				adaptor.AddChild(root_0, char_literal22_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:41:4: '+'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(41, 4);
				char_literal23=(IToken)Match(input,11,Follow._11_in_quantifierPrefix174); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal23_tree = (object)adaptor.Create(char_literal23);
				adaptor.AddChild(root_0, char_literal23_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:42:4: '?'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(42, 4);
				char_literal24=(IToken)Match(input,18,Follow._18_in_quantifierPrefix179); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal24_tree = (object)adaptor.Create(char_literal24);
				adaptor.AddChild(root_0, char_literal24_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:43:4: '{' decimalDigits ( ',' ( decimalDigits )? )? '}'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(43, 4);
				char_literal25=(IToken)Match(input,46,Follow._46_in_quantifierPrefix184); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal25_tree = (object)adaptor.Create(char_literal25);
				adaptor.AddChild(root_0, char_literal25_tree);
				}
				DebugLocation(43, 8);
				PushFollow(Follow._decimalDigits_in_quantifierPrefix186);
				decimalDigits26=decimalDigits();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, decimalDigits26.Tree);
				DebugLocation(43, 22);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:43:22: ( ',' ( decimalDigits )? )?
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==12))
				{
					alt8 = 1;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:43:23: ',' ( decimalDigits )?
					{
					DebugLocation(43, 23);
					char_literal27=(IToken)Match(input,12,Follow._12_in_quantifierPrefix189); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal27_tree = (object)adaptor.Create(char_literal27);
					adaptor.AddChild(root_0, char_literal27_tree);
					}
					DebugLocation(43, 27);
					// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:43:27: ( decimalDigits )?
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if (())
					{
						alt7 = 1;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:43:28: decimalDigits
						{
						DebugLocation(43, 28);
						PushFollow(Follow._decimalDigits_in_quantifierPrefix192);
						decimalDigits28=decimalDigits();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, decimalDigits28.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(7); }


					}
					break;

				}
				} finally { DebugExitSubRule(8); }

				DebugLocation(43, 46);
				char_literal29=(IToken)Match(input,48,Follow._48_in_quantifierPrefix198); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal29_tree = (object)adaptor.Create(char_literal29);
				adaptor.AddChild(root_0, char_literal29_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("quantifierPrefix", 7);
			LeaveRule("quantifierPrefix", 7);
			LeaveRule_quantifierPrefix();
			if (state.backtracking > 0) { Memoize(input, 7, quantifierPrefix_StartIndex); }

		}
		DebugLocation(44, 1);
		} finally { DebugExitRule(GrammarFileName, "quantifierPrefix"); }
		return retval;

	}
	// $ANTLR end "quantifierPrefix"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:46:1: atom : ( patternCharacter | '.' | '\\\\' atomEscape | characterClass | '(' disjunction ')' | '(:?' disjunction ')' );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 8);
		TraceIn("atom", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int atom_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal31 = default(IToken);
		IToken char_literal32 = default(IToken);
		IToken char_literal35 = default(IToken);
		IToken char_literal37 = default(IToken);
		IToken string_literal38 = default(IToken);
		IToken char_literal40 = default(IToken);
		AstParserRuleReturnScope<object, IToken> patternCharacter30 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> atomEscape33 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> characterClass34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction36 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction39 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal31_tree = default(object);
		object char_literal32_tree = default(object);
		object char_literal35_tree = default(object);
		object char_literal37_tree = default(object);
		object string_literal38_tree = default(object);
		object char_literal40_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(46, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 8)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:47:2: ( patternCharacter | '.' | '\\\\' atomEscape | characterClass | '(' disjunction ')' | '(:?' disjunction ')' )
			int alt10=6;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case 26:
				{
				int LA10_1 = input.LA(2);

				if ((EvaluatePredicate(synpred16_JavaScriptRegExp_fragment)))
				{
					alt10 = 1;
				}
				else if ((EvaluatePredicate(synpred19_JavaScriptRegExp_fragment)))
				{
					alt10 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 10, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 14:
				{
				alt10 = 2;
				}
				break;
			case 27:
				{
				alt10 = 3;
				}
				break;
			case 25:
				{
				alt10 = 4;
				}
				break;
			case 6:
				{
				int LA10_5 = input.LA(2);

				if ((EvaluatePredicate(synpred16_JavaScriptRegExp_fragment)))
				{
					alt10 = 1;
				}
				else if ((true))
				{
					alt10 = 6;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 10, 5, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 5:
				{
				alt10 = 5;
				}
				break;
			case 7:
			case 8:
			case 12:
			case 13:
			case 15:
			case 16:
			case 17:
			case 19:
			case 20:
			case 21:
			case 22:
			case 23:
			case 24:
			case 28:
			case 29:
			case 32:
			case 33:
			case 34:
			case 35:
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
			case 43:
			case 44:
			case 45:
				{
				alt10 = 1;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:47:4: patternCharacter
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(47, 4);
				PushFollow(Follow._patternCharacter_in_atom209);
				patternCharacter30=patternCharacter();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, patternCharacter30.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:48:4: '.'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(48, 4);
				char_literal31=(IToken)Match(input,14,Follow._14_in_atom214); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal31_tree = (object)adaptor.Create(char_literal31);
				adaptor.AddChild(root_0, char_literal31_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:49:4: '\\\\' atomEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(49, 4);
				char_literal32=(IToken)Match(input,27,Follow._27_in_atom219); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal32_tree = (object)adaptor.Create(char_literal32);
				adaptor.AddChild(root_0, char_literal32_tree);
				}
				DebugLocation(49, 9);
				PushFollow(Follow._atomEscape_in_atom221);
				atomEscape33=atomEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atomEscape33.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:50:4: characterClass
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(50, 4);
				PushFollow(Follow._characterClass_in_atom226);
				characterClass34=characterClass();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, characterClass34.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:51:4: '(' disjunction ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(51, 4);
				char_literal35=(IToken)Match(input,5,Follow._5_in_atom231); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal35_tree = (object)adaptor.Create(char_literal35);
				adaptor.AddChild(root_0, char_literal35_tree);
				}
				DebugLocation(51, 8);
				PushFollow(Follow._disjunction_in_atom233);
				disjunction36=disjunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction36.Tree);
				DebugLocation(51, 20);
				char_literal37=(IToken)Match(input,9,Follow._9_in_atom235); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal37_tree = (object)adaptor.Create(char_literal37);
				adaptor.AddChild(root_0, char_literal37_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:52:4: '(:?' disjunction ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(52, 4);
				string_literal38=(IToken)Match(input,6,Follow._6_in_atom240); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal38_tree = (object)adaptor.Create(string_literal38);
				adaptor.AddChild(root_0, string_literal38_tree);
				}
				DebugLocation(52, 10);
				PushFollow(Follow._disjunction_in_atom242);
				disjunction39=disjunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction39.Tree);
				DebugLocation(52, 22);
				char_literal40=(IToken)Match(input,9,Follow._9_in_atom244); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal40_tree = (object)adaptor.Create(char_literal40);
				adaptor.AddChild(root_0, char_literal40_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 8);
			LeaveRule("atom", 8);
			LeaveRule_atom();
			if (state.backtracking > 0) { Memoize(input, 8, atom_StartIndex); }

		}
		DebugLocation(53, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_patternCharacter();
	partial void LeaveRule_patternCharacter();

	// $ANTLR start "patternCharacter"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:55:1: patternCharacter : ~ ( '^' | '$' | '\\\\' | '.' | '*' | '+' | '?' | '(' | ')' | '[' | ']' | '{' | '}' | '|' ) ;
	[GrammarRule("patternCharacter")]
	private AstParserRuleReturnScope<object, IToken> patternCharacter()
	{
		EnterRule_patternCharacter();
		EnterRule("patternCharacter", 9);
		TraceIn("patternCharacter", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int patternCharacter_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set41 = default(IToken);

		object set41_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "patternCharacter");
		DebugLocation(55, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 9)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:56:2: (~ ( '^' | '$' | '\\\\' | '.' | '*' | '+' | '?' | '(' | ')' | '[' | ']' | '{' | '}' | '|' ) )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(56, 2);

			set41=(IToken)input.LT(1);
			if ((input.LA(1)>=6 && input.LA(1)<=8)||(input.LA(1)>=12 && input.LA(1)<=13)||(input.LA(1)>=15 && input.LA(1)<=17)||(input.LA(1)>=19 && input.LA(1)<=24)||input.LA(1)==26||(input.LA(1)>=28 && input.LA(1)<=29)||(input.LA(1)>=32 && input.LA(1)<=45))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set41));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("patternCharacter", 9);
			LeaveRule("patternCharacter", 9);
			LeaveRule_patternCharacter();
			if (state.backtracking > 0) { Memoize(input, 9, patternCharacter_StartIndex); }

		}
		DebugLocation(57, 1);
		} finally { DebugExitRule(GrammarFileName, "patternCharacter"); }
		return retval;

	}
	// $ANTLR end "patternCharacter"

	partial void EnterRule_atomEscape();
	partial void LeaveRule_atomEscape();

	// $ANTLR start "atomEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:59:1: atomEscape : ( decimalEscape | characterEscape | characterClassEscape );
	[GrammarRule("atomEscape")]
	private AstParserRuleReturnScope<object, IToken> atomEscape()
	{
		EnterRule_atomEscape();
		EnterRule("atomEscape", 10);
		TraceIn("atomEscape", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int atomEscape_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> decimalEscape42 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> characterEscape43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> characterClassEscape44 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "atomEscape");
		DebugLocation(59, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 10)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:60:2: ( decimalEscape | characterEscape | characterClassEscape )
			int alt11=3;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case 15:
				{
				alt11 = 1;
				}
				break;
			case 34:
			case 36:
			case 37:
			case 38:
			case 40:
			case 41:
			case 42:
			case 44:
				{
				alt11 = 2;
				}
				break;
			case 20:
			case 22:
			case 23:
			case 35:
			case 39:
			case 43:
				{
				alt11 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:60:4: decimalEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(60, 4);
				PushFollow(Follow._decimalEscape_in_atomEscape321);
				decimalEscape42=decimalEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, decimalEscape42.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:61:4: characterEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(61, 4);
				PushFollow(Follow._characterEscape_in_atomEscape326);
				characterEscape43=characterEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, characterEscape43.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:62:4: characterClassEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(62, 4);
				PushFollow(Follow._characterClassEscape_in_atomEscape331);
				characterClassEscape44=characterClassEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, characterClassEscape44.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atomEscape", 10);
			LeaveRule("atomEscape", 10);
			LeaveRule_atomEscape();
			if (state.backtracking > 0) { Memoize(input, 10, atomEscape_StartIndex); }

		}
		DebugLocation(63, 1);
		} finally { DebugExitRule(GrammarFileName, "atomEscape"); }
		return retval;

	}
	// $ANTLR end "atomEscape"

	partial void EnterRule_characterEscape();
	partial void LeaveRule_characterEscape();

	// $ANTLR start "characterEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:65:1: characterEscape : ( controlEscape | 'c' controlLetter | hexEscapeSequence | unicodeEscapeSequence | identityEscape );
	[GrammarRule("characterEscape")]
	private AstParserRuleReturnScope<object, IToken> characterEscape()
	{
		EnterRule_characterEscape();
		EnterRule("characterEscape", 11);
		TraceIn("characterEscape", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int characterEscape_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal46 = default(IToken);
		AstParserRuleReturnScope<object, IToken> controlEscape45 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> controlLetter47 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> hexEscapeSequence48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unicodeEscapeSequence49 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identityEscape50 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal46_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "characterEscape");
		DebugLocation(65, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 11)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:66:2: ( controlEscape | 'c' controlLetter | hexEscapeSequence | unicodeEscapeSequence | identityEscape )
			int alt12=5;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case 36:
			case 37:
			case 38:
			case 40:
			case 42:
				{
				alt12 = 1;
				}
				break;
			case 34:
				{
				alt12 = 2;
				}
				break;
			case 44:
				{
				alt12 = 3;
				}
				break;
			case 41:
				{
				alt12 = 4;
				}
				break;

				{
				alt12 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:66:4: controlEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(66, 4);
				PushFollow(Follow._controlEscape_in_characterEscape342);
				controlEscape45=controlEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, controlEscape45.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:67:4: 'c' controlLetter
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(67, 4);
				char_literal46=(IToken)Match(input,34,Follow._34_in_characterEscape347); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal46_tree = (object)adaptor.Create(char_literal46);
				adaptor.AddChild(root_0, char_literal46_tree);
				}
				DebugLocation(67, 8);
				PushFollow(Follow._controlLetter_in_characterEscape349);
				controlLetter47=controlLetter();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, controlLetter47.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:68:4: hexEscapeSequence
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(68, 4);
				PushFollow(Follow._hexEscapeSequence_in_characterEscape354);
				hexEscapeSequence48=hexEscapeSequence();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, hexEscapeSequence48.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:69:4: unicodeEscapeSequence
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(69, 4);
				PushFollow(Follow._unicodeEscapeSequence_in_characterEscape359);
				unicodeEscapeSequence49=unicodeEscapeSequence();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unicodeEscapeSequence49.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:70:4: identityEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(70, 4);
				PushFollow(Follow._identityEscape_in_characterEscape364);
				identityEscape50=identityEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identityEscape50.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("characterEscape", 11);
			LeaveRule("characterEscape", 11);
			LeaveRule_characterEscape();
			if (state.backtracking > 0) { Memoize(input, 11, characterEscape_StartIndex); }

		}
		DebugLocation(71, 1);
		} finally { DebugExitRule(GrammarFileName, "characterEscape"); }
		return retval;

	}
	// $ANTLR end "characterEscape"

	partial void EnterRule_controlEscape();
	partial void LeaveRule_controlEscape();

	// $ANTLR start "controlEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:73:1: controlEscape : ( 'f' | 'n' | 'r' | 't' | 'v' );
	[GrammarRule("controlEscape")]
	private AstParserRuleReturnScope<object, IToken> controlEscape()
	{
		EnterRule_controlEscape();
		EnterRule("controlEscape", 12);
		TraceIn("controlEscape", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int controlEscape_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set51 = default(IToken);

		object set51_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "controlEscape");
		DebugLocation(73, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 12)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:74:2: ( 'f' | 'n' | 'r' | 't' | 'v' )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(74, 2);

			set51=(IToken)input.LT(1);
			if ((input.LA(1)>=36 && input.LA(1)<=38)||input.LA(1)==40||input.LA(1)==42)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set51));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("controlEscape", 12);
			LeaveRule("controlEscape", 12);
			LeaveRule_controlEscape();
			if (state.backtracking > 0) { Memoize(input, 12, controlEscape_StartIndex); }

		}
		DebugLocation(79, 1);
		} finally { DebugExitRule(GrammarFileName, "controlEscape"); }
		return retval;

	}
	// $ANTLR end "controlEscape"

	partial void EnterRule_controlLetter();
	partial void LeaveRule_controlLetter();

	// $ANTLR start "controlLetter"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:81:1: controlLetter : ( 'a' .. 'z' | 'A' .. 'Z' ) ;
	[GrammarRule("controlLetter")]
	private AstParserRuleReturnScope<object, IToken> controlLetter()
	{
		EnterRule_controlLetter();
		EnterRule("controlLetter", 13);
		TraceIn("controlLetter", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int controlLetter_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set52 = default(IToken);

		object set52_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "controlLetter");
		DebugLocation(81, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 13)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:82:2: ( ( 'a' .. 'z' | 'A' .. 'Z' ) )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(82, 2);

			set52=(IToken)input.LT(1);
			if ()
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set52));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("controlLetter", 13);
			LeaveRule("controlLetter", 13);
			LeaveRule_controlLetter();
			if (state.backtracking > 0) { Memoize(input, 13, controlLetter_StartIndex); }

		}
		DebugLocation(83, 1);
		} finally { DebugExitRule(GrammarFileName, "controlLetter"); }
		return retval;

	}
	// $ANTLR end "controlLetter"

	partial void EnterRule_hexEscapeSequence();
	partial void LeaveRule_hexEscapeSequence();

	// $ANTLR start "hexEscapeSequence"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:85:1: hexEscapeSequence : 'x' hexDigit hexDigit ;
	[GrammarRule("hexEscapeSequence")]
	private AstParserRuleReturnScope<object, IToken> hexEscapeSequence()
	{
		EnterRule_hexEscapeSequence();
		EnterRule("hexEscapeSequence", 14);
		TraceIn("hexEscapeSequence", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int hexEscapeSequence_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal53 = default(IToken);
		AstParserRuleReturnScope<object, IToken> hexDigit54 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> hexDigit55 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal53_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "hexEscapeSequence");
		DebugLocation(85, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 14)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:86:2: ( 'x' hexDigit hexDigit )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:86:4: 'x' hexDigit hexDigit
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(86, 4);
			char_literal53=(IToken)Match(input,44,Follow._44_in_hexEscapeSequence426); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal53_tree = (object)adaptor.Create(char_literal53);
			adaptor.AddChild(root_0, char_literal53_tree);
			}
			DebugLocation(86, 8);
			PushFollow(Follow._hexDigit_in_hexEscapeSequence428);
			hexDigit54=hexDigit();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, hexDigit54.Tree);
			DebugLocation(86, 17);
			PushFollow(Follow._hexDigit_in_hexEscapeSequence430);
			hexDigit55=hexDigit();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, hexDigit55.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("hexEscapeSequence", 14);
			LeaveRule("hexEscapeSequence", 14);
			LeaveRule_hexEscapeSequence();
			if (state.backtracking > 0) { Memoize(input, 14, hexEscapeSequence_StartIndex); }

		}
		DebugLocation(87, 1);
		} finally { DebugExitRule(GrammarFileName, "hexEscapeSequence"); }
		return retval;

	}
	// $ANTLR end "hexEscapeSequence"

	partial void EnterRule_unicodeEscapeSequence();
	partial void LeaveRule_unicodeEscapeSequence();

	// $ANTLR start "unicodeEscapeSequence"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:89:1: unicodeEscapeSequence : 'u' hexDigit hexDigit hexDigit hexDigit ;
	[GrammarRule("unicodeEscapeSequence")]
	private AstParserRuleReturnScope<object, IToken> unicodeEscapeSequence()
	{
		EnterRule_unicodeEscapeSequence();
		EnterRule("unicodeEscapeSequence", 15);
		TraceIn("unicodeEscapeSequence", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int unicodeEscapeSequence_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal56 = default(IToken);
		AstParserRuleReturnScope<object, IToken> hexDigit57 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> hexDigit58 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> hexDigit59 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> hexDigit60 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal56_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "unicodeEscapeSequence");
		DebugLocation(89, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 15)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:90:2: ( 'u' hexDigit hexDigit hexDigit hexDigit )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:90:4: 'u' hexDigit hexDigit hexDigit hexDigit
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(90, 4);
			char_literal56=(IToken)Match(input,41,Follow._41_in_unicodeEscapeSequence441); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal56_tree = (object)adaptor.Create(char_literal56);
			adaptor.AddChild(root_0, char_literal56_tree);
			}
			DebugLocation(90, 8);
			PushFollow(Follow._hexDigit_in_unicodeEscapeSequence443);
			hexDigit57=hexDigit();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, hexDigit57.Tree);
			DebugLocation(90, 17);
			PushFollow(Follow._hexDigit_in_unicodeEscapeSequence445);
			hexDigit58=hexDigit();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, hexDigit58.Tree);
			DebugLocation(90, 26);
			PushFollow(Follow._hexDigit_in_unicodeEscapeSequence447);
			hexDigit59=hexDigit();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, hexDigit59.Tree);
			DebugLocation(90, 35);
			PushFollow(Follow._hexDigit_in_unicodeEscapeSequence449);
			hexDigit60=hexDigit();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, hexDigit60.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unicodeEscapeSequence", 15);
			LeaveRule("unicodeEscapeSequence", 15);
			LeaveRule_unicodeEscapeSequence();
			if (state.backtracking > 0) { Memoize(input, 15, unicodeEscapeSequence_StartIndex); }

		}
		DebugLocation(91, 1);
		} finally { DebugExitRule(GrammarFileName, "unicodeEscapeSequence"); }
		return retval;

	}
	// $ANTLR end "unicodeEscapeSequence"

	partial void EnterRule_hexDigit();
	partial void LeaveRule_hexDigit();

	// $ANTLR start "hexDigit"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:93:1: hexDigit : ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) ;
	[GrammarRule("hexDigit")]
	private AstParserRuleReturnScope<object, IToken> hexDigit()
	{
		EnterRule_hexDigit();
		EnterRule("hexDigit", 16);
		TraceIn("hexDigit", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int hexDigit_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set61 = default(IToken);

		object set61_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "hexDigit");
		DebugLocation(93, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 16)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:94:2: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(94, 2);

			set61=(IToken)input.LT(1);
			if ()
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set61));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("hexDigit", 16);
			LeaveRule("hexDigit", 16);
			LeaveRule_hexDigit();
			if (state.backtracking > 0) { Memoize(input, 16, hexDigit_StartIndex); }

		}
		DebugLocation(95, 1);
		} finally { DebugExitRule(GrammarFileName, "hexDigit"); }
		return retval;

	}
	// $ANTLR end "hexDigit"

	partial void EnterRule_identityEscape();
	partial void LeaveRule_identityEscape();

	// $ANTLR start "identityEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:97:1: identityEscape : 'a' .. 'z' ;
	[GrammarRule("identityEscape")]
	private AstParserRuleReturnScope<object, IToken> identityEscape()
	{
		EnterRule_identityEscape();
		EnterRule("identityEscape", 17);
		TraceIn("identityEscape", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int identityEscape_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set62 = default(IToken);

		object set62_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "identityEscape");
		DebugLocation(97, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 17)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:98:2: ( 'a' .. 'z' )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(98, 2);

			set62=(IToken)input.LT(1);
			if ()
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set62));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identityEscape", 17);
			LeaveRule("identityEscape", 17);
			LeaveRule_identityEscape();
			if (state.backtracking > 0) { Memoize(input, 17, identityEscape_StartIndex); }

		}
		DebugLocation(99, 1);
		} finally { DebugExitRule(GrammarFileName, "identityEscape"); }
		return retval;

	}
	// $ANTLR end "identityEscape"

	partial void EnterRule_decimalEscape();
	partial void LeaveRule_decimalEscape();

	// $ANTLR start "decimalEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:101:1: decimalEscape : decimalIntegerLiteral ;
	[GrammarRule("decimalEscape")]
	private AstParserRuleReturnScope<object, IToken> decimalEscape()
	{
		EnterRule_decimalEscape();
		EnterRule("decimalEscape", 18);
		TraceIn("decimalEscape", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int decimalEscape_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> decimalIntegerLiteral63 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "decimalEscape");
		DebugLocation(101, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 18)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:102:2: ( decimalIntegerLiteral )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:102:4: decimalIntegerLiteral
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(102, 4);
			PushFollow(Follow._decimalIntegerLiteral_in_decimalEscape498);
			decimalIntegerLiteral63=decimalIntegerLiteral();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, decimalIntegerLiteral63.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decimalEscape", 18);
			LeaveRule("decimalEscape", 18);
			LeaveRule_decimalEscape();
			if (state.backtracking > 0) { Memoize(input, 18, decimalEscape_StartIndex); }

		}
		DebugLocation(103, 1);
		} finally { DebugExitRule(GrammarFileName, "decimalEscape"); }
		return retval;

	}
	// $ANTLR end "decimalEscape"

	partial void EnterRule_decimalIntegerLiteral();
	partial void LeaveRule_decimalIntegerLiteral();

	// $ANTLR start "decimalIntegerLiteral"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:105:1: decimalIntegerLiteral : ( '0' | nonZeroDigit ( decimalDigits )? );
	[GrammarRule("decimalIntegerLiteral")]
	private AstParserRuleReturnScope<object, IToken> decimalIntegerLiteral()
	{
		EnterRule_decimalIntegerLiteral();
		EnterRule("decimalIntegerLiteral", 19);
		TraceIn("decimalIntegerLiteral", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int decimalIntegerLiteral_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal64 = default(IToken);
		AstParserRuleReturnScope<object, IToken> nonZeroDigit65 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> decimalDigits66 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal64_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "decimalIntegerLiteral");
		DebugLocation(105, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 19)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:106:2: ( '0' | nonZeroDigit ( decimalDigits )? )
			int alt14=2;
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if ((LA14_0==15))
			{
				alt14 = 1;
			}
			else if (())
			{
				alt14 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:106:4: '0'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(106, 4);
				char_literal64=(IToken)Match(input,15,Follow._15_in_decimalIntegerLiteral511); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal64_tree = (object)adaptor.Create(char_literal64);
				adaptor.AddChild(root_0, char_literal64_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:107:4: nonZeroDigit ( decimalDigits )?
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(107, 4);
				PushFollow(Follow._nonZeroDigit_in_decimalIntegerLiteral516);
				nonZeroDigit65=nonZeroDigit();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonZeroDigit65.Tree);
				DebugLocation(107, 17);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:107:17: ( decimalDigits )?
				int alt13=2;
				try { DebugEnterSubRule(13);
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if (())
				{
					alt13 = 1;
				}
				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:107:17: decimalDigits
					{
					DebugLocation(107, 17);
					PushFollow(Follow._decimalDigits_in_decimalIntegerLiteral518);
					decimalDigits66=decimalDigits();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, decimalDigits66.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(13); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decimalIntegerLiteral", 19);
			LeaveRule("decimalIntegerLiteral", 19);
			LeaveRule_decimalIntegerLiteral();
			if (state.backtracking > 0) { Memoize(input, 19, decimalIntegerLiteral_StartIndex); }

		}
		DebugLocation(108, 1);
		} finally { DebugExitRule(GrammarFileName, "decimalIntegerLiteral"); }
		return retval;

	}
	// $ANTLR end "decimalIntegerLiteral"

	partial void EnterRule_nonZeroDigit();
	partial void LeaveRule_nonZeroDigit();

	// $ANTLR start "nonZeroDigit"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:110:1: nonZeroDigit : '1' .. '9' ;
	[GrammarRule("nonZeroDigit")]
	private AstParserRuleReturnScope<object, IToken> nonZeroDigit()
	{
		EnterRule_nonZeroDigit();
		EnterRule("nonZeroDigit", 20);
		TraceIn("nonZeroDigit", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonZeroDigit_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set67 = default(IToken);

		object set67_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "nonZeroDigit");
		DebugLocation(110, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 20)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:111:2: ( '1' .. '9' )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(111, 2);

			set67=(IToken)input.LT(1);
			if ()
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set67));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonZeroDigit", 20);
			LeaveRule("nonZeroDigit", 20);
			LeaveRule_nonZeroDigit();
			if (state.backtracking > 0) { Memoize(input, 20, nonZeroDigit_StartIndex); }

		}
		DebugLocation(112, 1);
		} finally { DebugExitRule(GrammarFileName, "nonZeroDigit"); }
		return retval;

	}
	// $ANTLR end "nonZeroDigit"

	partial void EnterRule_decimalDigits();
	partial void LeaveRule_decimalDigits();

	// $ANTLR start "decimalDigits"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:114:1: decimalDigits : ( decimalDigit )+ ;
	[GrammarRule("decimalDigits")]
	private AstParserRuleReturnScope<object, IToken> decimalDigits()
	{
		EnterRule_decimalDigits();
		EnterRule("decimalDigits", 21);
		TraceIn("decimalDigits", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int decimalDigits_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> decimalDigit68 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "decimalDigits");
		DebugLocation(114, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 21)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:115:2: ( ( decimalDigit )+ )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:115:4: ( decimalDigit )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(115, 4);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:115:4: ( decimalDigit )+
			int cnt15=0;
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if (())
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:115:4: decimalDigit
					{
					DebugLocation(115, 4);
					PushFollow(Follow._decimalDigit_in_decimalDigits544);
					decimalDigit68=decimalDigit();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, decimalDigit68.Tree);

					}
					break;

				default:
					if (cnt15 >= 1)
						goto loop15;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee15 = new EarlyExitException( 15, input );
					DebugRecognitionException(eee15);
					throw eee15;
				}
				cnt15++;
			}
			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decimalDigits", 21);
			LeaveRule("decimalDigits", 21);
			LeaveRule_decimalDigits();
			if (state.backtracking > 0) { Memoize(input, 21, decimalDigits_StartIndex); }

		}
		DebugLocation(116, 1);
		} finally { DebugExitRule(GrammarFileName, "decimalDigits"); }
		return retval;

	}
	// $ANTLR end "decimalDigits"

	partial void EnterRule_decimalDigit();
	partial void LeaveRule_decimalDigit();

	// $ANTLR start "decimalDigit"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:118:1: decimalDigit : '0' .. '9' ;
	[GrammarRule("decimalDigit")]
	private AstParserRuleReturnScope<object, IToken> decimalDigit()
	{
		EnterRule_decimalDigit();
		EnterRule("decimalDigit", 22);
		TraceIn("decimalDigit", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int decimalDigit_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set69 = default(IToken);

		object set69_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "decimalDigit");
		DebugLocation(118, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 22)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:119:2: ( '0' .. '9' )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(119, 2);

			set69=(IToken)input.LT(1);
			if ()
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set69));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decimalDigit", 22);
			LeaveRule("decimalDigit", 22);
			LeaveRule_decimalDigit();
			if (state.backtracking > 0) { Memoize(input, 22, decimalDigit_StartIndex); }

		}
		DebugLocation(120, 1);
		} finally { DebugExitRule(GrammarFileName, "decimalDigit"); }
		return retval;

	}
	// $ANTLR end "decimalDigit"

	partial void EnterRule_characterClassEscape();
	partial void LeaveRule_characterClassEscape();

	// $ANTLR start "characterClassEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:122:1: characterClassEscape : ( 'd' | 'D' | 's' | 'S' | 'w' | 'W' );
	[GrammarRule("characterClassEscape")]
	private AstParserRuleReturnScope<object, IToken> characterClassEscape()
	{
		EnterRule_characterClassEscape();
		EnterRule("characterClassEscape", 23);
		TraceIn("characterClassEscape", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int characterClassEscape_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set70 = default(IToken);

		object set70_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "characterClassEscape");
		DebugLocation(122, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 23)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:123:2: ( 'd' | 'D' | 's' | 'S' | 'w' | 'W' )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(123, 2);

			set70=(IToken)input.LT(1);
			if (input.LA(1)==20||(input.LA(1)>=22 && input.LA(1)<=23)||input.LA(1)==35||input.LA(1)==39||input.LA(1)==43)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set70));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("characterClassEscape", 23);
			LeaveRule("characterClassEscape", 23);
			LeaveRule_characterClassEscape();
			if (state.backtracking > 0) { Memoize(input, 23, characterClassEscape_StartIndex); }

		}
		DebugLocation(129, 1);
		} finally { DebugExitRule(GrammarFileName, "characterClassEscape"); }
		return retval;

	}
	// $ANTLR end "characterClassEscape"

	partial void EnterRule_characterClass();
	partial void LeaveRule_characterClass();

	// $ANTLR start "characterClass"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:131:1: characterClass : ( '[' t=~ '^' classRanges ']' | '[^' classRanges ']' );
	[GrammarRule("characterClass")]
	private AstParserRuleReturnScope<object, IToken> characterClass()
	{
		EnterRule_characterClass();
		EnterRule("characterClass", 24);
		TraceIn("characterClass", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int characterClass_StartIndex = input.Index;

		object root_0 = default(object);

		IToken t = default(IToken);
		IToken char_literal71 = default(IToken);
		IToken char_literal73 = default(IToken);
		IToken string_literal74 = default(IToken);
		IToken char_literal76 = default(IToken);
		AstParserRuleReturnScope<object, IToken> classRanges72 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classRanges75 = default(AstParserRuleReturnScope<object, IToken>);

		object t_tree = default(object);
		object char_literal71_tree = default(object);
		object char_literal73_tree = default(object);
		object string_literal74_tree = default(object);
		object char_literal76_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "characterClass");
		DebugLocation(131, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 24)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:132:2: ( '[' t=~ '^' classRanges ']' | '[^' classRanges ']' )
			int alt16=2;
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==25))
			{
				alt16 = 1;
			}
			else if ((LA16_0==26))
			{
				alt16 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:132:4: '[' t=~ '^' classRanges ']'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(132, 4);
				char_literal71=(IToken)Match(input,25,Follow._25_in_characterClass605); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal71_tree = (object)adaptor.Create(char_literal71);
				adaptor.AddChild(root_0, char_literal71_tree);
				}
				DebugLocation(132, 9);

				t=(IToken)input.LT(1);
				if ((input.LA(1)>=4 && input.LA(1)<=30)||(input.LA(1)>=32 && input.LA(1)<=48))
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(t));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(132, 15);
				PushFollow(Follow._classRanges_in_characterClass612);
				classRanges72=classRanges();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classRanges72.Tree);
				DebugLocation(132, 27);
				char_literal73=(IToken)Match(input,30,Follow._30_in_characterClass614); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal73_tree = (object)adaptor.Create(char_literal73);
				adaptor.AddChild(root_0, char_literal73_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:133:4: '[^' classRanges ']'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(133, 4);
				string_literal74=(IToken)Match(input,26,Follow._26_in_characterClass619); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal74_tree = (object)adaptor.Create(string_literal74);
				adaptor.AddChild(root_0, string_literal74_tree);
				}
				DebugLocation(133, 9);
				PushFollow(Follow._classRanges_in_characterClass621);
				classRanges75=classRanges();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classRanges75.Tree);
				DebugLocation(133, 21);
				char_literal76=(IToken)Match(input,30,Follow._30_in_characterClass623); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal76_tree = (object)adaptor.Create(char_literal76);
				adaptor.AddChild(root_0, char_literal76_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("characterClass", 24);
			LeaveRule("characterClass", 24);
			LeaveRule_characterClass();
			if (state.backtracking > 0) { Memoize(input, 24, characterClass_StartIndex); }

		}
		DebugLocation(134, 1);
		} finally { DebugExitRule(GrammarFileName, "characterClass"); }
		return retval;

	}
	// $ANTLR end "characterClass"

	partial void EnterRule_classRanges();
	partial void LeaveRule_classRanges();

	// $ANTLR start "classRanges"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:136:1: classRanges : ( nonEmptyClassRanges )? ;
	[GrammarRule("classRanges")]
	private AstParserRuleReturnScope<object, IToken> classRanges()
	{
		EnterRule_classRanges();
		EnterRule("classRanges", 25);
		TraceIn("classRanges", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int classRanges_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> nonEmptyClassRanges77 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "classRanges");
		DebugLocation(136, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 25)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:137:2: ( ( nonEmptyClassRanges )? )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:137:4: ( nonEmptyClassRanges )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(137, 4);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:137:4: ( nonEmptyClassRanges )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if (((LA17_0>=4 && LA17_0<=29)||(LA17_0>=31 && LA17_0<=48)))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:137:4: nonEmptyClassRanges
				{
				DebugLocation(137, 4);
				PushFollow(Follow._nonEmptyClassRanges_in_classRanges634);
				nonEmptyClassRanges77=nonEmptyClassRanges();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonEmptyClassRanges77.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classRanges", 25);
			LeaveRule("classRanges", 25);
			LeaveRule_classRanges();
			if (state.backtracking > 0) { Memoize(input, 25, classRanges_StartIndex); }

		}
		DebugLocation(138, 1);
		} finally { DebugExitRule(GrammarFileName, "classRanges"); }
		return retval;

	}
	// $ANTLR end "classRanges"

	partial void EnterRule_nonEmptyClassRanges();
	partial void LeaveRule_nonEmptyClassRanges();

	// $ANTLR start "nonEmptyClassRanges"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:140:1: nonEmptyClassRanges : classAtom nonEmptyClassRangesContinued ;
	[GrammarRule("nonEmptyClassRanges")]
	private AstParserRuleReturnScope<object, IToken> nonEmptyClassRanges()
	{
		EnterRule_nonEmptyClassRanges();
		EnterRule("nonEmptyClassRanges", 26);
		TraceIn("nonEmptyClassRanges", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonEmptyClassRanges_StartIndex = input.Index;

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> classAtom78 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesContinued79 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "nonEmptyClassRanges");
		DebugLocation(140, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 26)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:141:2: ( classAtom nonEmptyClassRangesContinued )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:141:4: classAtom nonEmptyClassRangesContinued
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(141, 4);
			PushFollow(Follow._classAtom_in_nonEmptyClassRanges646);
			classAtom78=classAtom();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, classAtom78.Tree);
			DebugLocation(141, 14);
			PushFollow(Follow._nonEmptyClassRangesContinued_in_nonEmptyClassRanges648);
			nonEmptyClassRangesContinued79=nonEmptyClassRangesContinued();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, nonEmptyClassRangesContinued79.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonEmptyClassRanges", 26);
			LeaveRule("nonEmptyClassRanges", 26);
			LeaveRule_nonEmptyClassRanges();
			if (state.backtracking > 0) { Memoize(input, 26, nonEmptyClassRanges_StartIndex); }

		}
		DebugLocation(142, 1);
		} finally { DebugExitRule(GrammarFileName, "nonEmptyClassRanges"); }
		return retval;

	}
	// $ANTLR end "nonEmptyClassRanges"

	partial void EnterRule_nonEmptyClassRangesContinued();
	partial void LeaveRule_nonEmptyClassRangesContinued();

	// $ANTLR start "nonEmptyClassRangesContinued"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:144:1: nonEmptyClassRangesContinued : (| nonEmptyClassRangesNoDash | '-' classAtom classRanges );
	[GrammarRule("nonEmptyClassRangesContinued")]
	private AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesContinued()
	{
		EnterRule_nonEmptyClassRangesContinued();
		EnterRule("nonEmptyClassRangesContinued", 27);
		TraceIn("nonEmptyClassRangesContinued", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonEmptyClassRangesContinued_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal81 = default(IToken);
		AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesNoDash80 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classAtom82 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classRanges83 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal81_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "nonEmptyClassRangesContinued");
		DebugLocation(144, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 27)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:145:2: (| nonEmptyClassRangesNoDash | '-' classAtom classRanges )
			int alt18=3;
			try { DebugEnterDecision(18, false);
			switch (input.LA(1))
			{
			case 30:
				{
				int LA18_1 = input.LA(2);

				if ((EvaluatePredicate(synpred57_JavaScriptRegExp_fragment)))
				{
					alt18 = 1;
				}
				else if ((EvaluatePredicate(synpred58_JavaScriptRegExp_fragment)))
				{
					alt18 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 18, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case EOF:
				{
				alt18 = 1;
				}
				break;
			case 13:
				{
				int LA18_3 = input.LA(2);

				if ((EvaluatePredicate(synpred58_JavaScriptRegExp_fragment)))
				{
					alt18 = 2;
				}
				else if ((true))
				{
					alt18 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 18, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27:
			case 28:
			case 29:
			case 31:
			case 32:
			case 33:
			case 34:
			case 35:
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 48:
				{
				alt18 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 18, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:2: 
				{
				root_0 = (object)adaptor.Nil();

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:4: nonEmptyClassRangesNoDash
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(146, 4);
				PushFollow(Follow._nonEmptyClassRangesNoDash_in_nonEmptyClassRangesContinued664);
				nonEmptyClassRangesNoDash80=nonEmptyClassRangesNoDash();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonEmptyClassRangesNoDash80.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:147:4: '-' classAtom classRanges
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(147, 4);
				char_literal81=(IToken)Match(input,13,Follow._13_in_nonEmptyClassRangesContinued669); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal81_tree = (object)adaptor.Create(char_literal81);
				adaptor.AddChild(root_0, char_literal81_tree);
				}
				DebugLocation(147, 8);
				PushFollow(Follow._classAtom_in_nonEmptyClassRangesContinued671);
				classAtom82=classAtom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classAtom82.Tree);
				DebugLocation(147, 18);
				PushFollow(Follow._classRanges_in_nonEmptyClassRangesContinued673);
				classRanges83=classRanges();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classRanges83.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonEmptyClassRangesContinued", 27);
			LeaveRule("nonEmptyClassRangesContinued", 27);
			LeaveRule_nonEmptyClassRangesContinued();
			if (state.backtracking > 0) { Memoize(input, 27, nonEmptyClassRangesContinued_StartIndex); }

		}
		DebugLocation(148, 1);
		} finally { DebugExitRule(GrammarFileName, "nonEmptyClassRangesContinued"); }
		return retval;

	}
	// $ANTLR end "nonEmptyClassRangesContinued"

	partial void EnterRule_nonEmptyClassRangesNoDash();
	partial void LeaveRule_nonEmptyClassRangesNoDash();

	// $ANTLR start "nonEmptyClassRangesNoDash"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:150:1: nonEmptyClassRangesNoDash : (t= '-' classAtom |t=~ '-' classAtomNoDash nonEmptyClassRangesNoDashContinued );
	[GrammarRule("nonEmptyClassRangesNoDash")]
	private AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesNoDash()
	{
		EnterRule_nonEmptyClassRangesNoDash();
		EnterRule("nonEmptyClassRangesNoDash", 28);
		TraceIn("nonEmptyClassRangesNoDash", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonEmptyClassRangesNoDash_StartIndex = input.Index;

		object root_0 = default(object);

		IToken t = default(IToken);
		AstParserRuleReturnScope<object, IToken> classAtom84 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classAtomNoDash85 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesNoDashContinued86 = default(AstParserRuleReturnScope<object, IToken>);

		object t_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "nonEmptyClassRangesNoDash");
		DebugLocation(150, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 28)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:151:2: (t= '-' classAtom |t=~ '-' classAtomNoDash nonEmptyClassRangesNoDashContinued )
			int alt19=2;
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==13))
			{
				alt19 = 1;
			}
			else if (((LA19_0>=4 && LA19_0<=12)||(LA19_0>=14 && LA19_0<=48)))
			{
				alt19 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:151:4: t= '-' classAtom
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(151, 5);
				t=(IToken)Match(input,13,Follow._13_in_nonEmptyClassRangesNoDash686); if (state.failed) return retval;
				if (state.backtracking == 0) {
				t_tree = (object)adaptor.Create(t);
				adaptor.AddChild(root_0, t_tree);
				}
				DebugLocation(151, 10);
				PushFollow(Follow._classAtom_in_nonEmptyClassRangesNoDash688);
				classAtom84=classAtom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classAtom84.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:152:4: t=~ '-' classAtomNoDash nonEmptyClassRangesNoDashContinued
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(152, 5);

				t=(IToken)input.LT(1);
				if ((input.LA(1)>=4 && input.LA(1)<=12)||(input.LA(1)>=14 && input.LA(1)<=48))
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(t));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(152, 11);
				PushFollow(Follow._classAtomNoDash_in_nonEmptyClassRangesNoDash698);
				classAtomNoDash85=classAtomNoDash();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classAtomNoDash85.Tree);
				DebugLocation(152, 27);
				PushFollow(Follow._nonEmptyClassRangesNoDashContinued_in_nonEmptyClassRangesNoDash700);
				nonEmptyClassRangesNoDashContinued86=nonEmptyClassRangesNoDashContinued();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonEmptyClassRangesNoDashContinued86.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonEmptyClassRangesNoDash", 28);
			LeaveRule("nonEmptyClassRangesNoDash", 28);
			LeaveRule_nonEmptyClassRangesNoDash();
			if (state.backtracking > 0) { Memoize(input, 28, nonEmptyClassRangesNoDash_StartIndex); }

		}
		DebugLocation(153, 1);
		} finally { DebugExitRule(GrammarFileName, "nonEmptyClassRangesNoDash"); }
		return retval;

	}
	// $ANTLR end "nonEmptyClassRangesNoDash"

	partial void EnterRule_nonEmptyClassRangesNoDashContinued();
	partial void LeaveRule_nonEmptyClassRangesNoDashContinued();

	// $ANTLR start "nonEmptyClassRangesNoDashContinued"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:155:1: nonEmptyClassRangesNoDashContinued : (| nonEmptyClassRangesNoDash | '-' classAtom classRanges );
	[GrammarRule("nonEmptyClassRangesNoDashContinued")]
	private AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesNoDashContinued()
	{
		EnterRule_nonEmptyClassRangesNoDashContinued();
		EnterRule("nonEmptyClassRangesNoDashContinued", 29);
		TraceIn("nonEmptyClassRangesNoDashContinued", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonEmptyClassRangesNoDashContinued_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal88 = default(IToken);
		AstParserRuleReturnScope<object, IToken> nonEmptyClassRangesNoDash87 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classAtom89 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classRanges90 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal88_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "nonEmptyClassRangesNoDashContinued");
		DebugLocation(155, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 29)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:156:2: (| nonEmptyClassRangesNoDash | '-' classAtom classRanges )
			int alt20=3;
			try { DebugEnterDecision(20, false);
			switch (input.LA(1))
			{
			case 30:
				{
				int LA20_1 = input.LA(2);

				if ((EvaluatePredicate(synpred60_JavaScriptRegExp_fragment)))
				{
					alt20 = 1;
				}
				else if ((EvaluatePredicate(synpred61_JavaScriptRegExp_fragment)))
				{
					alt20 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case EOF:
				{
				alt20 = 1;
				}
				break;
			case 13:
				{
				int LA20_3 = input.LA(2);

				if ((EvaluatePredicate(synpred61_JavaScriptRegExp_fragment)))
				{
					alt20 = 2;
				}
				else if ((true))
				{
					alt20 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27:
			case 28:
			case 29:
			case 31:
			case 32:
			case 33:
			case 34:
			case 35:
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 48:
				{
				alt20 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:2: 
				{
				root_0 = (object)adaptor.Nil();

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:4: nonEmptyClassRangesNoDash
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(157, 4);
				PushFollow(Follow._nonEmptyClassRangesNoDash_in_nonEmptyClassRangesNoDashContinued716);
				nonEmptyClassRangesNoDash87=nonEmptyClassRangesNoDash();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonEmptyClassRangesNoDash87.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:158:4: '-' classAtom classRanges
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(158, 4);
				char_literal88=(IToken)Match(input,13,Follow._13_in_nonEmptyClassRangesNoDashContinued721); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal88_tree = (object)adaptor.Create(char_literal88);
				adaptor.AddChild(root_0, char_literal88_tree);
				}
				DebugLocation(158, 8);
				PushFollow(Follow._classAtom_in_nonEmptyClassRangesNoDashContinued723);
				classAtom89=classAtom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classAtom89.Tree);
				DebugLocation(158, 18);
				PushFollow(Follow._classRanges_in_nonEmptyClassRangesNoDashContinued725);
				classRanges90=classRanges();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classRanges90.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonEmptyClassRangesNoDashContinued", 29);
			LeaveRule("nonEmptyClassRangesNoDashContinued", 29);
			LeaveRule_nonEmptyClassRangesNoDashContinued();
			if (state.backtracking > 0) { Memoize(input, 29, nonEmptyClassRangesNoDashContinued_StartIndex); }

		}
		DebugLocation(159, 1);
		} finally { DebugExitRule(GrammarFileName, "nonEmptyClassRangesNoDashContinued"); }
		return retval;

	}
	// $ANTLR end "nonEmptyClassRangesNoDashContinued"

	partial void EnterRule_classAtom();
	partial void LeaveRule_classAtom();

	// $ANTLR start "classAtom"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:161:1: classAtom : ( '-' | classAtomNoDash );
	[GrammarRule("classAtom")]
	private AstParserRuleReturnScope<object, IToken> classAtom()
	{
		EnterRule_classAtom();
		EnterRule("classAtom", 30);
		TraceIn("classAtom", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int classAtom_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal91 = default(IToken);
		AstParserRuleReturnScope<object, IToken> classAtomNoDash92 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal91_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "classAtom");
		DebugLocation(161, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 30)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:162:2: ( '-' | classAtomNoDash )
			int alt21=2;
			try { DebugEnterDecision(21, false);
			int LA21_0 = input.LA(1);

			if ((LA21_0==13))
			{
				alt21 = 1;
			}
			else if (((LA21_0>=4 && LA21_0<=12)||(LA21_0>=14 && LA21_0<=29)||(LA21_0>=31 && LA21_0<=48)))
			{
				alt21 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:162:4: '-'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(162, 4);
				char_literal91=(IToken)Match(input,13,Follow._13_in_classAtom736); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal91_tree = (object)adaptor.Create(char_literal91);
				adaptor.AddChild(root_0, char_literal91_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:163:4: classAtomNoDash
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(163, 4);
				PushFollow(Follow._classAtomNoDash_in_classAtom741);
				classAtomNoDash92=classAtomNoDash();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classAtomNoDash92.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classAtom", 30);
			LeaveRule("classAtom", 30);
			LeaveRule_classAtom();
			if (state.backtracking > 0) { Memoize(input, 30, classAtom_StartIndex); }

		}
		DebugLocation(164, 1);
		} finally { DebugExitRule(GrammarFileName, "classAtom"); }
		return retval;

	}
	// $ANTLR end "classAtom"

	partial void EnterRule_classAtomNoDash();
	partial void LeaveRule_classAtomNoDash();

	// $ANTLR start "classAtomNoDash"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:166:1: classAtomNoDash : (~ ( '\\\\' | ']' | '-' ) | '\\\\' classEscape );
	[GrammarRule("classAtomNoDash")]
	private AstParserRuleReturnScope<object, IToken> classAtomNoDash()
	{
		EnterRule_classAtomNoDash();
		EnterRule("classAtomNoDash", 31);
		TraceIn("classAtomNoDash", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int classAtomNoDash_StartIndex = input.Index;

		object root_0 = default(object);

		IToken set93 = default(IToken);
		IToken char_literal94 = default(IToken);
		AstParserRuleReturnScope<object, IToken> classEscape95 = default(AstParserRuleReturnScope<object, IToken>);

		object set93_tree = default(object);
		object char_literal94_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "classAtomNoDash");
		DebugLocation(166, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 31)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:167:2: (~ ( '\\\\' | ']' | '-' ) | '\\\\' classEscape )
			int alt22=2;
			try { DebugEnterDecision(22, false);
			int LA22_0 = input.LA(1);

			if (((LA22_0>=4 && LA22_0<=12)||(LA22_0>=14 && LA22_0<=26)||(LA22_0>=28 && LA22_0<=29)||(LA22_0>=31 && LA22_0<=48)))
			{
				alt22 = 1;
			}
			else if ((LA22_0==27))
			{
				alt22 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:167:4: ~ ( '\\\\' | ']' | '-' )
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(167, 4);

				set93=(IToken)input.LT(1);
				if ((input.LA(1)>=4 && input.LA(1)<=12)||(input.LA(1)>=14 && input.LA(1)<=26)||(input.LA(1)>=28 && input.LA(1)<=29)||(input.LA(1)>=31 && input.LA(1)<=48))
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set93));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:168:4: '\\\\' classEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(168, 4);
				char_literal94=(IToken)Match(input,27,Follow._27_in_classAtomNoDash768); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal94_tree = (object)adaptor.Create(char_literal94);
				adaptor.AddChild(root_0, char_literal94_tree);
				}
				DebugLocation(168, 9);
				PushFollow(Follow._classEscape_in_classAtomNoDash770);
				classEscape95=classEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classEscape95.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classAtomNoDash", 31);
			LeaveRule("classAtomNoDash", 31);
			LeaveRule_classAtomNoDash();
			if (state.backtracking > 0) { Memoize(input, 31, classAtomNoDash_StartIndex); }

		}
		DebugLocation(169, 1);
		} finally { DebugExitRule(GrammarFileName, "classAtomNoDash"); }
		return retval;

	}
	// $ANTLR end "classAtomNoDash"

	partial void EnterRule_classEscape();
	partial void LeaveRule_classEscape();

	// $ANTLR start "classEscape"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:171:1: classEscape : ( decimalEscape | 'b' | characterEscape | characterClassEscape );
	[GrammarRule("classEscape")]
	private AstParserRuleReturnScope<object, IToken> classEscape()
	{
		EnterRule_classEscape();
		EnterRule("classEscape", 32);
		TraceIn("classEscape", 32);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);
		int classEscape_StartIndex = input.Index;

		object root_0 = default(object);

		IToken char_literal97 = default(IToken);
		AstParserRuleReturnScope<object, IToken> decimalEscape96 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> characterEscape98 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> characterClassEscape99 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal97_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "classEscape");
		DebugLocation(171, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 32)) { return retval; }

			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:172:2: ( decimalEscape | 'b' | characterEscape | characterClassEscape )
			int alt23=4;
			try { DebugEnterDecision(23, false);
			switch (input.LA(1))
			{
			case 15:
				{
				alt23 = 1;
				}
				break;
			case 33:
				{
				alt23 = 2;
				}
				break;
			case 34:
			case 36:
			case 37:
			case 38:
			case 40:
			case 41:
			case 42:
			case 44:
				{
				alt23 = 3;
				}
				break;
			case 20:
			case 22:
			case 23:
			case 35:
			case 39:
			case 43:
				{
				alt23 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:172:4: decimalEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(172, 4);
				PushFollow(Follow._decimalEscape_in_classEscape781);
				decimalEscape96=decimalEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, decimalEscape96.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:173:4: 'b'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(173, 4);
				char_literal97=(IToken)Match(input,33,Follow._33_in_classEscape786); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal97_tree = (object)adaptor.Create(char_literal97);
				adaptor.AddChild(root_0, char_literal97_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:174:4: characterEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(174, 4);
				PushFollow(Follow._characterEscape_in_classEscape791);
				characterEscape98=characterEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, characterEscape98.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:175:4: characterClassEscape
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(175, 4);
				PushFollow(Follow._characterClassEscape_in_classEscape796);
				characterClassEscape99=characterClassEscape();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, characterClassEscape99.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classEscape", 32);
			LeaveRule("classEscape", 32);
			LeaveRule_classEscape();
			if (state.backtracking > 0) { Memoize(input, 32, classEscape_StartIndex); }

		}
		DebugLocation(176, 1);
		} finally { DebugExitRule(GrammarFileName, "classEscape"); }
		return retval;

	}
	// $ANTLR end "classEscape"

	partial void EnterRule_synpred3_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred3_JavaScriptRegExp_fragment();

	// $ANTLR start synpred3_JavaScriptRegExp
	public void synpred3_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred3_JavaScriptRegExp_fragment();
		EnterRule("synpred3_JavaScriptRegExp_fragment", 35);
		TraceIn("synpred3_JavaScriptRegExp_fragment", 35);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:4: ( assertion )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:4: assertion
			{
			DebugLocation(22, 4);
			PushFollow(Follow._assertion_in_synpred3_JavaScriptRegExp90);
			assertion();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_JavaScriptRegExp_fragment", 35);
			LeaveRule("synpred3_JavaScriptRegExp_fragment", 35);
			LeaveRule_synpred3_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred3_JavaScriptRegExp

	partial void EnterRule_synpred16_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred16_JavaScriptRegExp_fragment();

	// $ANTLR start synpred16_JavaScriptRegExp
	public void synpred16_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred16_JavaScriptRegExp_fragment();
		EnterRule("synpred16_JavaScriptRegExp_fragment", 48);
		TraceIn("synpred16_JavaScriptRegExp_fragment", 48);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:47:4: ( patternCharacter )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:47:4: patternCharacter
			{
			DebugLocation(47, 4);
			PushFollow(Follow._patternCharacter_in_synpred16_JavaScriptRegExp209);
			patternCharacter();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred16_JavaScriptRegExp_fragment", 48);
			LeaveRule("synpred16_JavaScriptRegExp_fragment", 48);
			LeaveRule_synpred16_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred16_JavaScriptRegExp

	partial void EnterRule_synpred19_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred19_JavaScriptRegExp_fragment();

	// $ANTLR start synpred19_JavaScriptRegExp
	public void synpred19_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred19_JavaScriptRegExp_fragment();
		EnterRule("synpred19_JavaScriptRegExp_fragment", 51);
		TraceIn("synpred19_JavaScriptRegExp_fragment", 51);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:50:4: ( characterClass )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:50:4: characterClass
			{
			DebugLocation(50, 4);
			PushFollow(Follow._characterClass_in_synpred19_JavaScriptRegExp226);
			characterClass();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred19_JavaScriptRegExp_fragment", 51);
			LeaveRule("synpred19_JavaScriptRegExp_fragment", 51);
			LeaveRule_synpred19_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred19_JavaScriptRegExp

	partial void EnterRule_synpred57_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred57_JavaScriptRegExp_fragment();

	// $ANTLR start synpred57_JavaScriptRegExp
	public void synpred57_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred57_JavaScriptRegExp_fragment();
		EnterRule("synpred57_JavaScriptRegExp_fragment", 89);
		TraceIn("synpred57_JavaScriptRegExp_fragment", 89);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:2: ()
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:2: 
			{
			}

		}
		finally
		{
			TraceOut("synpred57_JavaScriptRegExp_fragment", 89);
			LeaveRule("synpred57_JavaScriptRegExp_fragment", 89);
			LeaveRule_synpred57_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred57_JavaScriptRegExp

	partial void EnterRule_synpred58_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred58_JavaScriptRegExp_fragment();

	// $ANTLR start synpred58_JavaScriptRegExp
	public void synpred58_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred58_JavaScriptRegExp_fragment();
		EnterRule("synpred58_JavaScriptRegExp_fragment", 90);
		TraceIn("synpred58_JavaScriptRegExp_fragment", 90);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:4: ( nonEmptyClassRangesNoDash )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:146:4: nonEmptyClassRangesNoDash
			{
			DebugLocation(146, 4);
			PushFollow(Follow._nonEmptyClassRangesNoDash_in_synpred58_JavaScriptRegExp664);
			nonEmptyClassRangesNoDash();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred58_JavaScriptRegExp_fragment", 90);
			LeaveRule("synpred58_JavaScriptRegExp_fragment", 90);
			LeaveRule_synpred58_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred58_JavaScriptRegExp

	partial void EnterRule_synpred60_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred60_JavaScriptRegExp_fragment();

	// $ANTLR start synpred60_JavaScriptRegExp
	public void synpred60_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred60_JavaScriptRegExp_fragment();
		EnterRule("synpred60_JavaScriptRegExp_fragment", 92);
		TraceIn("synpred60_JavaScriptRegExp_fragment", 92);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:2: ()
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:2: 
			{
			}

		}
		finally
		{
			TraceOut("synpred60_JavaScriptRegExp_fragment", 92);
			LeaveRule("synpred60_JavaScriptRegExp_fragment", 92);
			LeaveRule_synpred60_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred60_JavaScriptRegExp

	partial void EnterRule_synpred61_JavaScriptRegExp_fragment();
	partial void LeaveRule_synpred61_JavaScriptRegExp_fragment();

	// $ANTLR start synpred61_JavaScriptRegExp
	public void synpred61_JavaScriptRegExp_fragment()
	{
		EnterRule_synpred61_JavaScriptRegExp_fragment();
		EnterRule("synpred61_JavaScriptRegExp_fragment", 93);
		TraceIn("synpred61_JavaScriptRegExp_fragment", 93);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:4: ( nonEmptyClassRangesNoDash )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:157:4: nonEmptyClassRangesNoDash
			{
			DebugLocation(157, 4);
			PushFollow(Follow._nonEmptyClassRangesNoDash_in_synpred61_JavaScriptRegExp716);
			nonEmptyClassRangesNoDash();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred61_JavaScriptRegExp_fragment", 93);
			LeaveRule("synpred61_JavaScriptRegExp_fragment", 93);
			LeaveRule_synpred61_JavaScriptRegExp_fragment();
		}
	}
	// $ANTLR end synpred61_JavaScriptRegExp
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _disjunction_in_pattern47 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_pattern49 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alternative_in_disjunction60 = new BitSet(new ulong[]{0x800000000002UL});
		public static readonly BitSet _47_in_disjunction63 = new BitSet(new ulong[]{0xBFFFBFFBF1F0UL});
		public static readonly BitSet _disjunction_in_disjunction65 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_alternative78 = new BitSet(new ulong[]{0x3FFFBFFBF1F2UL});
		public static readonly BitSet _assertion_in_term90 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_term95 = new BitSet(new ulong[]{0x400000040C02UL});
		public static readonly BitSet _quantifier_in_term97 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _31_in_assertion109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _4_in_assertion114 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _29_in_assertion119 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _28_in_assertion124 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _8_in_assertion129 = new BitSet(new ulong[]{0xBFFFBFFBF1F0UL});
		public static readonly BitSet _disjunction_in_assertion131 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _9_in_assertion133 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _7_in_assertion138 = new BitSet(new ulong[]{0xBFFFBFFBF1F0UL});
		public static readonly BitSet _disjunction_in_assertion140 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _9_in_assertion142 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quantifierPrefix_in_quantifier153 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _18_in_quantifier156 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _10_in_quantifierPrefix169 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _11_in_quantifierPrefix174 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _18_in_quantifierPrefix179 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _46_in_quantifierPrefix184 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _decimalDigits_in_quantifierPrefix186 = new BitSet(new ulong[]{0x1000000001000UL});
		public static readonly BitSet _12_in_quantifierPrefix189 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _decimalDigits_in_quantifierPrefix192 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_quantifierPrefix198 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _patternCharacter_in_atom209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _14_in_atom214 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _27_in_atom219 = new BitSet(new ulong[]{0x1FFC00D08000UL});
		public static readonly BitSet _atomEscape_in_atom221 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterClass_in_atom226 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _5_in_atom231 = new BitSet(new ulong[]{0xBFFFBFFBF1F0UL});
		public static readonly BitSet _disjunction_in_atom233 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _9_in_atom235 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _6_in_atom240 = new BitSet(new ulong[]{0xBFFFBFFBF1F0UL});
		public static readonly BitSet _disjunction_in_atom242 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _9_in_atom244 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _decimalEscape_in_atomEscape321 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterEscape_in_atomEscape326 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterClassEscape_in_atomEscape331 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _controlEscape_in_characterEscape342 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _34_in_characterEscape347 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _controlLetter_in_characterEscape349 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _hexEscapeSequence_in_characterEscape354 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unicodeEscapeSequence_in_characterEscape359 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identityEscape_in_characterEscape364 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _44_in_hexEscapeSequence426 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _hexDigit_in_hexEscapeSequence428 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _hexDigit_in_hexEscapeSequence430 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _41_in_unicodeEscapeSequence441 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _hexDigit_in_unicodeEscapeSequence443 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _hexDigit_in_unicodeEscapeSequence445 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _hexDigit_in_unicodeEscapeSequence447 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _hexDigit_in_unicodeEscapeSequence449 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _decimalIntegerLiteral_in_decimalEscape498 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _15_in_decimalIntegerLiteral511 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonZeroDigit_in_decimalIntegerLiteral516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _decimalDigits_in_decimalIntegerLiteral518 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _decimalDigit_in_decimalDigits544 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _25_in_characterClass605 = new BitSet(new ulong[]{0x1FFFF7FFFFFF0UL});
		public static readonly BitSet _set_in_characterClass609 = new BitSet(new ulong[]{0x1FFFFFFFFFFF0UL});
		public static readonly BitSet _classRanges_in_characterClass612 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _30_in_characterClass614 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _26_in_characterClass619 = new BitSet(new ulong[]{0x1FFFFFFFFFFF0UL});
		public static readonly BitSet _classRanges_in_characterClass621 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _30_in_characterClass623 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonEmptyClassRanges_in_classRanges634 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classAtom_in_nonEmptyClassRanges646 = new BitSet(new ulong[]{0x1FFFFFFFFFFF0UL});
		public static readonly BitSet _nonEmptyClassRangesContinued_in_nonEmptyClassRanges648 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonEmptyClassRangesNoDash_in_nonEmptyClassRangesContinued664 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _13_in_nonEmptyClassRangesContinued669 = new BitSet(new ulong[]{0x1FFFFBFFFFFF0UL});
		public static readonly BitSet _classAtom_in_nonEmptyClassRangesContinued671 = new BitSet(new ulong[]{0x1FFFFBFFFFFF0UL});
		public static readonly BitSet _classRanges_in_nonEmptyClassRangesContinued673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _13_in_nonEmptyClassRangesNoDash686 = new BitSet(new ulong[]{0x1FFFFBFFFFFF0UL});
		public static readonly BitSet _classAtom_in_nonEmptyClassRangesNoDash688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_nonEmptyClassRangesNoDash695 = new BitSet(new ulong[]{0x1FFFFBFFFDFF0UL});
		public static readonly BitSet _classAtomNoDash_in_nonEmptyClassRangesNoDash698 = new BitSet(new ulong[]{0x1FFFFFFFFFFF0UL});
		public static readonly BitSet _nonEmptyClassRangesNoDashContinued_in_nonEmptyClassRangesNoDash700 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonEmptyClassRangesNoDash_in_nonEmptyClassRangesNoDashContinued716 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _13_in_nonEmptyClassRangesNoDashContinued721 = new BitSet(new ulong[]{0x1FFFFBFFFFFF0UL});
		public static readonly BitSet _classAtom_in_nonEmptyClassRangesNoDashContinued723 = new BitSet(new ulong[]{0x1FFFFBFFFFFF0UL});
		public static readonly BitSet _classRanges_in_nonEmptyClassRangesNoDashContinued725 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _13_in_classAtom736 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classAtomNoDash_in_classAtom741 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_classAtomNoDash752 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _27_in_classAtomNoDash768 = new BitSet(new ulong[]{0x1FFE00D08000UL});
		public static readonly BitSet _classEscape_in_classAtomNoDash770 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _decimalEscape_in_classEscape781 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _33_in_classEscape786 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterEscape_in_classEscape791 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterClassEscape_in_classEscape796 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assertion_in_synpred3_JavaScriptRegExp90 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _patternCharacter_in_synpred16_JavaScriptRegExp209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _characterClass_in_synpred19_JavaScriptRegExp226 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonEmptyClassRangesNoDash_in_synpred58_JavaScriptRegExp664 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonEmptyClassRangesNoDash_in_synpred61_JavaScriptRegExp716 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
