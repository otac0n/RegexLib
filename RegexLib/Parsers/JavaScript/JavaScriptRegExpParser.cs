//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 Parsers\\JavaScript\\JavaScriptRegExp.g 2012-07-15 09:22:25

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	using System.Text;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  RegexLib.Parsers.JavaScript 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
 internal  partial class JavaScriptRegExpParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "CARAT", "CHAR", "COMMA", "DIGIT", "DOLLAR", "DOT", "L_CURLY", "PIPE", "PLUS", "QUESTION", "R_CURLY", "STAR"
	};
	public const int EOF=-1;
	public const int CARAT=4;
	public const int CHAR=5;
	public const int COMMA=6;
	public const int DIGIT=7;
	public const int DOLLAR=8;
	public const int DOT=9;
	public const int L_CURLY=10;
	public const int PIPE=11;
	public const int PLUS=12;
	public const int QUESTION=13;
	public const int R_CURLY=14;
	public const int STAR=15;

	public JavaScriptRegExpParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public JavaScriptRegExpParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return JavaScriptRegExpParser.tokenNames; } }
	public override string GrammarFileName { get { return "Parsers\\JavaScript\\JavaScriptRegExp.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_pattern();
	partial void LeaveRule_pattern();

	// $ANTLR start "pattern"
	// Parsers\\JavaScript\\JavaScriptRegExp.g:26:8: public pattern returns [RegexNode value] : disjunction EOF ;
	[GrammarRule("pattern")]
	public RegexNode pattern()
	{
		EnterRule_pattern();
		EnterRule("pattern", 1);
		TraceIn("pattern", 1);
		RegexNode value = default(RegexNode);


		RegexNode disjunction1 = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "pattern");
		DebugLocation(26, 1);
		try
		{
			// Parsers\\JavaScript\\JavaScriptRegExp.g:27:2: ( disjunction EOF )
			DebugEnterAlt(1);
			// Parsers\\JavaScript\\JavaScriptRegExp.g:27:4: disjunction EOF
			{
			DebugLocation(27, 4);
			PushFollow(Follow._disjunction_in_pattern141);
			disjunction1=disjunction();
			PopFollow();

			DebugLocation(27, 16);
			Match(input,EOF,Follow._EOF_in_pattern143); 
			DebugLocation(27, 20);
			 return disjunction1; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("pattern", 1);
			LeaveRule("pattern", 1);
			LeaveRule_pattern();
		}
		DebugLocation(28, 1);
		} finally { DebugExitRule(GrammarFileName, "pattern"); }
		return value;

	}
	// $ANTLR end "pattern"

	partial void EnterRule_disjunction();
	partial void LeaveRule_disjunction();

	// $ANTLR start "disjunction"
	// Parsers\\JavaScript\\JavaScriptRegExp.g:30:1: disjunction returns [RegexNode value] : first= alternative ( PIPE rest= disjunction )? ;
	[GrammarRule("disjunction")]
	private RegexNode disjunction()
	{
		EnterRule_disjunction();
		EnterRule("disjunction", 2);
		TraceIn("disjunction", 2);
		RegexNode value = default(RegexNode);


		RegexNode first = default(RegexNode);
		RegexNode rest = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "disjunction");
		DebugLocation(30, 1);
		try
		{
			// Parsers\\JavaScript\\JavaScriptRegExp.g:31:2: (first= alternative ( PIPE rest= disjunction )? )
			DebugEnterAlt(1);
			// Parsers\\JavaScript\\JavaScriptRegExp.g:31:4: first= alternative ( PIPE rest= disjunction )?
			{
			DebugLocation(31, 9);
			PushFollow(Follow._alternative_in_disjunction162);
			first=alternative();
			PopFollow();

			DebugLocation(31, 22);
			// Parsers\\JavaScript\\JavaScriptRegExp.g:31:22: ( PIPE rest= disjunction )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==PIPE))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:31:23: PIPE rest= disjunction
				{
				DebugLocation(31, 23);
				Match(input,PIPE,Follow._PIPE_in_disjunction165); 
				DebugLocation(31, 32);
				PushFollow(Follow._disjunction_in_disjunction169);
				rest=disjunction();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(31, 47);
			 return rest != null ? new AlternationNode(first, rest) : first; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("disjunction", 2);
			LeaveRule("disjunction", 2);
			LeaveRule_disjunction();
		}
		DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "disjunction"); }
		return value;

	}
	// $ANTLR end "disjunction"

	partial void EnterRule_alternative();
	partial void LeaveRule_alternative();

	// $ANTLR start "alternative"
	// Parsers\\JavaScript\\JavaScriptRegExp.g:34:1: alternative returns [RegexNode value] : ( terms |);
	[GrammarRule("alternative")]
	private RegexNode alternative()
	{
		EnterRule_alternative();
		EnterRule("alternative", 3);
		TraceIn("alternative", 3);
		RegexNode value = default(RegexNode);


		RegexNode terms2 = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "alternative");
		DebugLocation(34, 1);
		try
		{
			// Parsers\\JavaScript\\JavaScriptRegExp.g:35:2: ( terms |)
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if (((LA2_0>=CARAT && LA2_0<=DOT)))
			{
				alt2 = 1;
			}
			else if ((LA2_0==EOF||LA2_0==PIPE))
			{
				alt2 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:35:4: terms
				{
				DebugLocation(35, 4);
				PushFollow(Follow._terms_in_alternative188);
				terms2=terms();
				PopFollow();

				DebugLocation(35, 10);
				 return terms2; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:36:16: 
				{
				DebugLocation(36, 16);
				 return new EmptyNode(); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("alternative", 3);
			LeaveRule("alternative", 3);
			LeaveRule_alternative();
		}
		DebugLocation(37, 1);
		} finally { DebugExitRule(GrammarFileName, "alternative"); }
		return value;

	}
	// $ANTLR end "alternative"

	partial void EnterRule_terms();
	partial void LeaveRule_terms();

	// $ANTLR start "terms"
	// Parsers\\JavaScript\\JavaScriptRegExp.g:39:1: terms returns [RegexNode value] : first= term (rest= terms )? ;
	[GrammarRule("terms")]
	private RegexNode terms()
	{
		EnterRule_terms();
		EnterRule("terms", 4);
		TraceIn("terms", 4);
		RegexNode value = default(RegexNode);


		RegexNode first = default(RegexNode);
		RegexNode rest = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "terms");
		DebugLocation(39, 1);
		try
		{
			// Parsers\\JavaScript\\JavaScriptRegExp.g:40:2: (first= term (rest= terms )? )
			DebugEnterAlt(1);
			// Parsers\\JavaScript\\JavaScriptRegExp.g:40:4: first= term (rest= terms )?
			{
			DebugLocation(40, 9);
			PushFollow(Follow._term_in_terms214);
			first=term();
			PopFollow();

			DebugLocation(40, 19);
			// Parsers\\JavaScript\\JavaScriptRegExp.g:40:19: (rest= terms )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if (((LA3_0>=CARAT && LA3_0<=DOT)))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:40:19: rest= terms
				{
				DebugLocation(40, 19);
				PushFollow(Follow._terms_in_terms218);
				rest=terms();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(40, 27);
			 return rest != null ? new ConcatenationNode(first, rest) : first; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("terms", 4);
			LeaveRule("terms", 4);
			LeaveRule_terms();
		}
		DebugLocation(41, 1);
		} finally { DebugExitRule(GrammarFileName, "terms"); }
		return value;

	}
	// $ANTLR end "terms"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// Parsers\\JavaScript\\JavaScriptRegExp.g:43:1: term returns [RegexNode value] : ( assertion | atom ( quantifier )? );
	[GrammarRule("term")]
	private RegexNode term()
	{
		EnterRule_term();
		EnterRule("term", 5);
		TraceIn("term", 5);
		RegexNode value = default(RegexNode);


		RegexNode assertion3 = default(RegexNode);
		Quantifier quantifier4 = default(Quantifier);
		RegexNode atom5 = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(43, 1);
		try
		{
			// Parsers\\JavaScript\\JavaScriptRegExp.g:44:2: ( assertion | atom ( quantifier )? )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==CARAT||LA5_0==DOLLAR))
			{
				alt5 = 1;
			}
			else if (((LA5_0>=CHAR && LA5_0<=DIGIT)||LA5_0==DOT))
			{
				alt5 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:44:4: assertion
				{
				DebugLocation(44, 4);
				PushFollow(Follow._assertion_in_term236);
				assertion3=assertion();
				PopFollow();

				DebugLocation(44, 14);
				 return assertion3; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:45:4: atom ( quantifier )?
				{
				DebugLocation(45, 4);
				PushFollow(Follow._atom_in_term243);
				atom5=atom();
				PopFollow();

				DebugLocation(45, 9);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:45:9: ( quantifier )?
				int alt4=2;
				try { DebugEnterSubRule(4);
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==L_CURLY||(LA4_0>=PLUS && LA4_0<=QUESTION)||LA4_0==STAR))
				{
					alt4 = 1;
				}
				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// Parsers\\JavaScript\\JavaScriptRegExp.g:45:9: quantifier
					{
					DebugLocation(45, 9);
					PushFollow(Follow._quantifier_in_term245);
					quantifier4=quantifier();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(4); }

				DebugLocation(45, 21);
				 return quantifier4 != null ? new RepetitionNode(atom5, quantifier4.Min, quantifier4.Max, quantifier4.Eager) : atom5; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("term", 5);
			LeaveRule("term", 5);
			LeaveRule_term();
		}
		DebugLocation(46, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return value;

	}
	// $ANTLR end "term"

	partial void EnterRule_assertion();
	partial void LeaveRule_assertion();

	// $ANTLR start "assertion"
	// Parsers\\JavaScript\\JavaScriptRegExp.g:48:1: assertion returns [RegexNode value] : ( CARAT | DOLLAR );
	[GrammarRule("assertion")]
	private RegexNode assertion()
	{
		EnterRule_assertion();
		EnterRule("assertion", 6);
		TraceIn("assertion", 6);
		RegexNode value = default(RegexNode);


		try { DebugEnterRule(GrammarFileName, "assertion");
		DebugLocation(48, 1);
		try
		{
			// Parsers\\JavaScript\\JavaScriptRegExp.g:49:2: ( CARAT | DOLLAR )
			int alt6=2;
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==CARAT))
			{
				alt6 = 1;
			}
			else if ((LA6_0==DOLLAR))
			{
				alt6 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:49:4: CARAT
				{
				DebugLocation(49, 4);
				Match(input,CARAT,Follow._CARAT_in_assertion263); 
				DebugLocation(49, 10);
				 return new StringStartAnchorNode(); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:50:4: DOLLAR
				{
				DebugLocation(50, 4);
				Match(input,DOLLAR,Follow._DOLLAR_in_assertion270); 
				DebugLocation(50, 11);
				 return new StringEndAnchorNode(); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assertion", 6);
			LeaveRule("assertion", 6);
			LeaveRule_assertion();
		}
		DebugLocation(51, 1);
		} finally { DebugExitRule(GrammarFileName, "assertion"); }
		return value;

	}
	// $ANTLR end "assertion"

	partial void EnterRule_quantifier();
	partial void LeaveRule_quantifier();

	// $ANTLR start "quantifier"
	// Parsers\\JavaScript\\JavaScriptRegExp.g:53:1: quantifier returns [Quantifier value] : q= quantifierPrefix ( QUESTION )? ;
	[GrammarRule("quantifier")]
	private Quantifier quantifier()
	{
		EnterRule_quantifier();
		EnterRule("quantifier", 7);
		TraceIn("quantifier", 7);
		Quantifier value = default(Quantifier);


		IToken QUESTION6 = default(IToken);
		Quantifier q = default(Quantifier);

		try { DebugEnterRule(GrammarFileName, "quantifier");
		DebugLocation(53, 1);
		try
		{
			// Parsers\\JavaScript\\JavaScriptRegExp.g:54:2: (q= quantifierPrefix ( QUESTION )? )
			DebugEnterAlt(1);
			// Parsers\\JavaScript\\JavaScriptRegExp.g:54:4: q= quantifierPrefix ( QUESTION )?
			{
			DebugLocation(54, 5);
			PushFollow(Follow._quantifierPrefix_in_quantifier289);
			q=quantifierPrefix();
			PopFollow();

			DebugLocation(54, 23);
			// Parsers\\JavaScript\\JavaScriptRegExp.g:54:23: ( QUESTION )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==QUESTION))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:54:23: QUESTION
				{
				DebugLocation(54, 23);
				QUESTION6=(IToken)Match(input,QUESTION,Follow._QUESTION_in_quantifier291); 

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(55, 3);

						var quant = q;
						quant.Eager = QUESTION6 == null;
						return quant;
					

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("quantifier", 7);
			LeaveRule("quantifier", 7);
			LeaveRule_quantifier();
		}
		DebugLocation(60, 1);
		} finally { DebugExitRule(GrammarFileName, "quantifier"); }
		return value;

	}
	// $ANTLR end "quantifier"

	partial void EnterRule_quantifierPrefix();
	partial void LeaveRule_quantifierPrefix();

	// $ANTLR start "quantifierPrefix"
	// Parsers\\JavaScript\\JavaScriptRegExp.g:62:1: quantifierPrefix returns [Quantifier value] : ( STAR | PLUS | QUESTION | L_CURLY min= decimalDigits ( COMMA (max= decimalDigits )? )? R_CURLY );
	[GrammarRule("quantifierPrefix")]
	private Quantifier quantifierPrefix()
	{
		EnterRule_quantifierPrefix();
		EnterRule("quantifierPrefix", 8);
		TraceIn("quantifierPrefix", 8);
		Quantifier value = default(Quantifier);


		IToken COMMA7 = default(IToken);
		int? min = default(int?);
		int? max = default(int?);

		try { DebugEnterRule(GrammarFileName, "quantifierPrefix");
		DebugLocation(62, 1);
		try
		{
			// Parsers\\JavaScript\\JavaScriptRegExp.g:63:2: ( STAR | PLUS | QUESTION | L_CURLY min= decimalDigits ( COMMA (max= decimalDigits )? )? R_CURLY )
			int alt10=4;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case STAR:
				{
				alt10 = 1;
				}
				break;
			case PLUS:
				{
				alt10 = 2;
				}
				break;
			case QUESTION:
				{
				alt10 = 3;
				}
				break;
			case L_CURLY:
				{
				alt10 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:63:4: STAR
				{
				DebugLocation(63, 4);
				Match(input,STAR,Follow._STAR_in_quantifierPrefix311); 
				DebugLocation(63, 9);
				 return new Quantifier { Min = 0 }; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:64:4: PLUS
				{
				DebugLocation(64, 4);
				Match(input,PLUS,Follow._PLUS_in_quantifierPrefix318); 
				DebugLocation(64, 9);
				 return new Quantifier { Min = 1 }; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:65:4: QUESTION
				{
				DebugLocation(65, 4);
				Match(input,QUESTION,Follow._QUESTION_in_quantifierPrefix325); 
				DebugLocation(65, 13);
				 return new Quantifier { Min = 0, Max = 1 }; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:66:4: L_CURLY min= decimalDigits ( COMMA (max= decimalDigits )? )? R_CURLY
				{
				DebugLocation(66, 4);
				Match(input,L_CURLY,Follow._L_CURLY_in_quantifierPrefix332); 
				DebugLocation(66, 15);
				PushFollow(Follow._decimalDigits_in_quantifierPrefix336);
				min=decimalDigits();
				PopFollow();

				DebugLocation(66, 30);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:66:30: ( COMMA (max= decimalDigits )? )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==COMMA))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// Parsers\\JavaScript\\JavaScriptRegExp.g:66:31: COMMA (max= decimalDigits )?
					{
					DebugLocation(66, 31);
					COMMA7=(IToken)Match(input,COMMA,Follow._COMMA_in_quantifierPrefix339); 
					DebugLocation(66, 40);
					// Parsers\\JavaScript\\JavaScriptRegExp.g:66:40: (max= decimalDigits )?
					int alt8=2;
					try { DebugEnterSubRule(8);
					try { DebugEnterDecision(8, false);
					int LA8_0 = input.LA(1);

					if ((LA8_0==DIGIT))
					{
						alt8 = 1;
					}
					} finally { DebugExitDecision(8); }
					switch (alt8)
					{
					case 1:
						DebugEnterAlt(1);
						// Parsers\\JavaScript\\JavaScriptRegExp.g:66:40: max= decimalDigits
						{
						DebugLocation(66, 40);
						PushFollow(Follow._decimalDigits_in_quantifierPrefix343);
						max=decimalDigits();
						PopFollow();


						}
						break;

					}
					} finally { DebugExitSubRule(8); }


					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(66, 58);
				Match(input,R_CURLY,Follow._R_CURLY_in_quantifierPrefix348); 
				DebugLocation(67, 3);

							var minValue = min.Value;
							if (COMMA7 == null)
							{
								return new Quantifier { Min = minValue, Max = minValue };
							}
							else if (!max.HasValue)
							{
								return new Quantifier { Min = minValue, Max = null };
							}
							else
							{
								var maxValue = max.Value;
								return new Quantifier { Min = minValue, Max = maxValue };
							}
						

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("quantifierPrefix", 8);
			LeaveRule("quantifierPrefix", 8);
			LeaveRule_quantifierPrefix();
		}
		DebugLocation(83, 1);
		} finally { DebugExitRule(GrammarFileName, "quantifierPrefix"); }
		return value;

	}
	// $ANTLR end "quantifierPrefix"

	partial void EnterRule_decimalDigits();
	partial void LeaveRule_decimalDigits();

	// $ANTLR start "decimalDigits"
	// Parsers\\JavaScript\\JavaScriptRegExp.g:85:1: decimalDigits returns [int? value] : (v+= DIGIT )+ ;
	[GrammarRule("decimalDigits")]
	private int? decimalDigits()
	{
		EnterRule_decimalDigits();
		EnterRule("decimalDigits", 9);
		TraceIn("decimalDigits", 9);
		int? value = default(int?);


		IToken v = default(IToken);
		List<IToken> list_v = null;

		try { DebugEnterRule(GrammarFileName, "decimalDigits");
		DebugLocation(85, 1);
		try
		{
			// Parsers\\JavaScript\\JavaScriptRegExp.g:86:2: ( (v+= DIGIT )+ )
			DebugEnterAlt(1);
			// Parsers\\JavaScript\\JavaScriptRegExp.g:86:4: (v+= DIGIT )+
			{
			DebugLocation(86, 4);
			// Parsers\\JavaScript\\JavaScriptRegExp.g:86:4: (v+= DIGIT )+
			int cnt11=0;
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==DIGIT))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// Parsers\\JavaScript\\JavaScriptRegExp.g:86:5: v+= DIGIT
					{
					DebugLocation(86, 6);
					v=(IToken)Match(input,DIGIT,Follow._DIGIT_in_decimalDigits370); 
					if (list_v==null) list_v=new List<IToken>();
					list_v.Add(v);


					}
					break;

				default:
					if (cnt11 >= 1)
						goto loop11;

					EarlyExitException eee11 = new EarlyExitException( 11, input );
					DebugRecognitionException(eee11);
					throw eee11;
				}
				cnt11++;
			}
			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(87, 3);

						var sb = new StringBuilder();
						list_v.ForEach(d => sb.Append(d.Text));
						return int.Parse(sb.ToString());
					

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("decimalDigits", 9);
			LeaveRule("decimalDigits", 9);
			LeaveRule_decimalDigits();
		}
		DebugLocation(92, 1);
		} finally { DebugExitRule(GrammarFileName, "decimalDigits"); }
		return value;

	}
	// $ANTLR end "decimalDigits"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// Parsers\\JavaScript\\JavaScriptRegExp.g:98:1: atom returns [RegexNode value] : (c= ( CHAR | DIGIT | COMMA ) | DOT );
	[GrammarRule("atom")]
	private RegexNode atom()
	{
		EnterRule_atom();
		EnterRule("atom", 10);
		TraceIn("atom", 10);
		RegexNode value = default(RegexNode);


		IToken c = default(IToken);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(98, 1);
		try
		{
			// Parsers\\JavaScript\\JavaScriptRegExp.g:99:2: (c= ( CHAR | DIGIT | COMMA ) | DOT )
			int alt12=2;
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if (((LA12_0>=CHAR && LA12_0<=DIGIT)))
			{
				alt12 = 1;
			}
			else if ((LA12_0==DOT))
			{
				alt12 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:99:4: c= ( CHAR | DIGIT | COMMA )
				{
				DebugLocation(99, 5);

				c=(IToken)input.LT(1);
				if ((input.LA(1)>=CHAR && input.LA(1)<=DIGIT))
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(99, 29);
				 return new CharacterClassNode(c.Text[0]); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Parsers\\JavaScript\\JavaScriptRegExp.g:100:4: DOT
				{
				DebugLocation(100, 4);
				Match(input,DOT,Follow._DOT_in_atom423); 
				DebugLocation(100, 8);
				 return new CharacterClassNode(); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 10);
			LeaveRule("atom", 10);
			LeaveRule_atom();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return value;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _disjunction_in_pattern141 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_pattern143 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alternative_in_disjunction162 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _PIPE_in_disjunction165 = new BitSet(new ulong[]{0xBF0UL});
		public static readonly BitSet _disjunction_in_disjunction169 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _terms_in_alternative188 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_terms214 = new BitSet(new ulong[]{0x3F2UL});
		public static readonly BitSet _terms_in_terms218 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assertion_in_term236 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_term243 = new BitSet(new ulong[]{0xB402UL});
		public static readonly BitSet _quantifier_in_term245 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CARAT_in_assertion263 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOLLAR_in_assertion270 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quantifierPrefix_in_quantifier289 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _QUESTION_in_quantifier291 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_quantifierPrefix311 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_quantifierPrefix318 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _QUESTION_in_quantifierPrefix325 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _L_CURLY_in_quantifierPrefix332 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _decimalDigits_in_quantifierPrefix336 = new BitSet(new ulong[]{0x4040UL});
		public static readonly BitSet _COMMA_in_quantifierPrefix339 = new BitSet(new ulong[]{0x4080UL});
		public static readonly BitSet _decimalDigits_in_quantifierPrefix343 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _R_CURLY_in_quantifierPrefix348 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DIGIT_in_decimalDigits370 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _set_in_atom406 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_atom423 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  RegexLib.Parsers.JavaScript 
