//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g 2012-07-13 08:17:17

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  RegexLib.Parsers.JavaScript 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
 internal  partial class JavaScriptRegExpParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "CARAT", "CHAR", "DOLLAR", "DOT", "PIPE"
	};
	public const int EOF=-1;
	public const int CARAT=4;
	public const int CHAR=5;
	public const int DOLLAR=6;
	public const int DOT=7;
	public const int PIPE=8;

	public JavaScriptRegExpParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public JavaScriptRegExpParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return JavaScriptRegExpParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_pattern();
	partial void LeaveRule_pattern();

	// $ANTLR start "pattern"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:17:8: public pattern returns [RegexNode value] : disjunction EOF ;
	[GrammarRule("pattern")]
	public RegexNode pattern()
	{
		EnterRule_pattern();
		EnterRule("pattern", 1);
		TraceIn("pattern", 1);
		RegexNode value = default(RegexNode);


		RegexNode disjunction1 = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "pattern");
		DebugLocation(17, 1);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:18:2: ( disjunction EOF )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:18:4: disjunction EOF
			{
			DebugLocation(18, 4);
			PushFollow(Follow._disjunction_in_pattern88);
			disjunction1=disjunction();
			PopFollow();

			DebugLocation(18, 16);
			Match(input,EOF,Follow._EOF_in_pattern90); 
			DebugLocation(18, 20);
			 return disjunction1; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("pattern", 1);
			LeaveRule("pattern", 1);
			LeaveRule_pattern();
		}
		DebugLocation(19, 1);
		} finally { DebugExitRule(GrammarFileName, "pattern"); }
		return value;

	}
	// $ANTLR end "pattern"

	partial void EnterRule_disjunction();
	partial void LeaveRule_disjunction();

	// $ANTLR start "disjunction"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:21:1: disjunction returns [RegexNode value] : first= alternative ( PIPE rest= disjunction )? ;
	[GrammarRule("disjunction")]
	private RegexNode disjunction()
	{
		EnterRule_disjunction();
		EnterRule("disjunction", 2);
		TraceIn("disjunction", 2);
		RegexNode value = default(RegexNode);


		RegexNode first = default(RegexNode);
		RegexNode rest = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "disjunction");
		DebugLocation(21, 1);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:2: (first= alternative ( PIPE rest= disjunction )? )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:4: first= alternative ( PIPE rest= disjunction )?
			{
			DebugLocation(22, 9);
			PushFollow(Follow._alternative_in_disjunction109);
			first=alternative();
			PopFollow();

			DebugLocation(22, 22);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:22: ( PIPE rest= disjunction )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==PIPE))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:22:23: PIPE rest= disjunction
				{
				DebugLocation(22, 23);
				Match(input,PIPE,Follow._PIPE_in_disjunction112); 
				DebugLocation(22, 32);
				PushFollow(Follow._disjunction_in_disjunction116);
				rest=disjunction();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(22, 47);
			 return rest != null ? new AlternationNode(first, rest) : first; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("disjunction", 2);
			LeaveRule("disjunction", 2);
			LeaveRule_disjunction();
		}
		DebugLocation(23, 1);
		} finally { DebugExitRule(GrammarFileName, "disjunction"); }
		return value;

	}
	// $ANTLR end "disjunction"

	partial void EnterRule_alternative();
	partial void LeaveRule_alternative();

	// $ANTLR start "alternative"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:25:1: alternative returns [RegexNode value] : ( terms |);
	[GrammarRule("alternative")]
	private RegexNode alternative()
	{
		EnterRule_alternative();
		EnterRule("alternative", 3);
		TraceIn("alternative", 3);
		RegexNode value = default(RegexNode);


		RegexNode terms2 = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "alternative");
		DebugLocation(25, 1);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:26:2: ( terms |)
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if (((LA2_0>=CARAT && LA2_0<=DOT)))
			{
				alt2 = 1;
			}
			else if ((LA2_0==EOF||LA2_0==PIPE))
			{
				alt2 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:26:4: terms
				{
				DebugLocation(26, 4);
				PushFollow(Follow._terms_in_alternative135);
				terms2=terms();
				PopFollow();

				DebugLocation(26, 10);
				 return terms2; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:27:16: 
				{
				DebugLocation(27, 16);
				 return new EmptyNode(); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("alternative", 3);
			LeaveRule("alternative", 3);
			LeaveRule_alternative();
		}
		DebugLocation(28, 1);
		} finally { DebugExitRule(GrammarFileName, "alternative"); }
		return value;

	}
	// $ANTLR end "alternative"

	partial void EnterRule_terms();
	partial void LeaveRule_terms();

	// $ANTLR start "terms"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:30:1: terms returns [RegexNode value] : first= term (rest= terms )? ;
	[GrammarRule("terms")]
	private RegexNode terms()
	{
		EnterRule_terms();
		EnterRule("terms", 4);
		TraceIn("terms", 4);
		RegexNode value = default(RegexNode);


		RegexNode first = default(RegexNode);
		RegexNode rest = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "terms");
		DebugLocation(30, 1);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:31:2: (first= term (rest= terms )? )
			DebugEnterAlt(1);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:31:4: first= term (rest= terms )?
			{
			DebugLocation(31, 9);
			PushFollow(Follow._term_in_terms161);
			first=term();
			PopFollow();

			DebugLocation(31, 19);
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:31:19: (rest= terms )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if (((LA3_0>=CARAT && LA3_0<=DOT)))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:31:19: rest= terms
				{
				DebugLocation(31, 19);
				PushFollow(Follow._terms_in_terms165);
				rest=terms();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(31, 27);
			 return rest != null ? new ConcatenationNode(first, rest) : first; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("terms", 4);
			LeaveRule("terms", 4);
			LeaveRule_terms();
		}
		DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "terms"); }
		return value;

	}
	// $ANTLR end "terms"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:34:1: term returns [RegexNode value] : ( assertion | atom );
	[GrammarRule("term")]
	private RegexNode term()
	{
		EnterRule_term();
		EnterRule("term", 5);
		TraceIn("term", 5);
		RegexNode value = default(RegexNode);


		RegexNode assertion3 = default(RegexNode);
		RegexNode atom4 = default(RegexNode);

		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(34, 1);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:35:2: ( assertion | atom )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==CARAT||LA4_0==DOLLAR))
			{
				alt4 = 1;
			}
			else if ((LA4_0==CHAR||LA4_0==DOT))
			{
				alt4 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:35:4: assertion
				{
				DebugLocation(35, 4);
				PushFollow(Follow._assertion_in_term183);
				assertion3=assertion();
				PopFollow();

				DebugLocation(35, 14);
				 return assertion3; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:36:4: atom
				{
				DebugLocation(36, 4);
				PushFollow(Follow._atom_in_term190);
				atom4=atom();
				PopFollow();

				DebugLocation(36, 9);
				 return atom4; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("term", 5);
			LeaveRule("term", 5);
			LeaveRule_term();
		}
		DebugLocation(37, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return value;

	}
	// $ANTLR end "term"

	partial void EnterRule_assertion();
	partial void LeaveRule_assertion();

	// $ANTLR start "assertion"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:39:1: assertion returns [RegexNode value] : ( CARAT | DOLLAR );
	[GrammarRule("assertion")]
	private RegexNode assertion()
	{
		EnterRule_assertion();
		EnterRule("assertion", 6);
		TraceIn("assertion", 6);
		RegexNode value = default(RegexNode);


		try { DebugEnterRule(GrammarFileName, "assertion");
		DebugLocation(39, 1);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:40:2: ( CARAT | DOLLAR )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==CARAT))
			{
				alt5 = 1;
			}
			else if ((LA5_0==DOLLAR))
			{
				alt5 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:40:4: CARAT
				{
				DebugLocation(40, 4);
				Match(input,CARAT,Follow._CARAT_in_assertion207); 
				DebugLocation(40, 10);
				 return new StringStartAnchorNode(); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:41:4: DOLLAR
				{
				DebugLocation(41, 4);
				Match(input,DOLLAR,Follow._DOLLAR_in_assertion214); 
				DebugLocation(41, 11);
				 return new StringEndAnchorNode(); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assertion", 6);
			LeaveRule("assertion", 6);
			LeaveRule_assertion();
		}
		DebugLocation(42, 1);
		} finally { DebugExitRule(GrammarFileName, "assertion"); }
		return value;

	}
	// $ANTLR end "assertion"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:44:1: atom returns [RegexNode value] : ( CHAR | DOT );
	[GrammarRule("atom")]
	private RegexNode atom()
	{
		EnterRule_atom();
		EnterRule("atom", 7);
		TraceIn("atom", 7);
		RegexNode value = default(RegexNode);


		IToken CHAR5 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(44, 1);
		try
		{
			// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:45:2: ( CHAR | DOT )
			int alt6=2;
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==CHAR))
			{
				alt6 = 1;
			}
			else if ((LA6_0==DOT))
			{
				alt6 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:45:4: CHAR
				{
				DebugLocation(45, 4);
				CHAR5=(IToken)Match(input,CHAR,Follow._CHAR_in_atom231); 
				DebugLocation(45, 9);
				 return new CharacterClassNode(CHAR5.Text[0]); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\otac0n\\Projects\\RegexLib\\RegexLib\\Parsers\\JavaScript\\JavaScriptRegExp.g:46:4: DOT
				{
				DebugLocation(46, 4);
				Match(input,DOT,Follow._DOT_in_atom238); 
				DebugLocation(46, 8);
				 return new CharacterClassNode(); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 7);
			LeaveRule("atom", 7);
			LeaveRule_atom();
		}
		DebugLocation(47, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return value;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _disjunction_in_pattern88 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_pattern90 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alternative_in_disjunction109 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _PIPE_in_disjunction112 = new BitSet(new ulong[]{0x1F0UL});
		public static readonly BitSet _disjunction_in_disjunction116 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _terms_in_alternative135 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_terms161 = new BitSet(new ulong[]{0xF2UL});
		public static readonly BitSet _terms_in_terms165 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assertion_in_term183 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_term190 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CARAT_in_assertion207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOLLAR_in_assertion214 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_in_atom231 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_atom238 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  RegexLib.Parsers.JavaScript 
